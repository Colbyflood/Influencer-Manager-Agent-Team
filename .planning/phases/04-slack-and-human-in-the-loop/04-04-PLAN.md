---
phase: 04-slack-and-human-in-the-loop
plan: 04
type: execute
wave: 3
depends_on:
  - 04-01
  - 04-02
  - 04-03
files_modified:
  - src/negotiation/slack/dispatcher.py
  - src/negotiation/slack/__init__.py
  - tests/slack/test_dispatcher.py
autonomous: true
requirements:
  - HUMAN-01
  - HUMAN-02
  - HUMAN-03
  - HUMAN-04

must_haves:
  truths:
    - "Trigger engine runs as pre-processing gate before the negotiation loop -- if any trigger fires, email is escalated immediately"
    - "Human takeover check runs before processing any thread -- if human-managed, thread is skipped silently"
    - "Escalation actions from the negotiation loop are dispatched to Slack with full Block Kit messages"
    - "Accept actions from the negotiation loop produce agreement alerts posted to the agreements Slack channel"
    - "Escalation messages include all required fields: influencer name, email, client name, reason with evidence, rates, suggested actions, details link"
    - "Agreement messages include all required fields: influencer name, email, client name, agreed rate, platform, deliverables, CPM, next steps"
  artifacts:
    - path: "src/negotiation/slack/dispatcher.py"
      provides: "SlackDispatcher orchestrating trigger evaluation, human takeover check, and Slack notification dispatch"
      min_lines: 100
    - path: "tests/slack/test_dispatcher.py"
      provides: "Integration tests for the full dispatch pipeline"
      min_lines: 120
  key_links:
    - from: "src/negotiation/slack/dispatcher.py"
      to: "src/negotiation/slack/triggers.py"
      via: "evaluate_triggers called as pre-processing gate"
      pattern: "evaluate_triggers"
    - from: "src/negotiation/slack/dispatcher.py"
      to: "src/negotiation/slack/takeover.py"
      via: "detect_human_reply and is_human_managed called before processing"
      pattern: "detect_human_reply|is_human_managed"
    - from: "src/negotiation/slack/dispatcher.py"
      to: "src/negotiation/slack/client.py"
      via: "SlackNotifier.post_escalation and post_agreement called for dispatch"
      pattern: "post_escalation|post_agreement"
    - from: "src/negotiation/slack/dispatcher.py"
      to: "src/negotiation/slack/blocks.py"
      via: "build_escalation_blocks and build_agreement_blocks called to format messages"
      pattern: "build_escalation_blocks|build_agreement_blocks"
    - from: "src/negotiation/slack/dispatcher.py"
      to: "src/negotiation/llm/models.py"
      via: "EscalationPayload and AgreementPayload consumed for dispatch data"
      pattern: "EscalationPayload|AgreementPayload"
---

<objective>
Wire the trigger engine, human takeover, and Slack notifications into a unified dispatch layer that integrates with the Phase 3 negotiation loop, converting action dicts into Slack messages.

Purpose: This is the integration plan that connects all Phase 4 components. The dispatcher sits between the negotiation loop and Slack, handling pre-processing (triggers, human check) and post-processing (escalation/agreement dispatch).
Output: Complete Slack dispatch pipeline that converts negotiation outcomes into actionable Slack notifications.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/04-slack-and-human-in-the-loop/04-RESEARCH.md
@.planning/phases/04-slack-and-human-in-the-loop/04-CONTEXT.md
@.planning/phases/04-slack-and-human-in-the-loop/04-01-SUMMARY.md
@.planning/phases/04-slack-and-human-in-the-loop/04-02-SUMMARY.md
@.planning/phases/04-slack-and-human-in-the-loop/04-03-SUMMARY.md
@src/negotiation/llm/negotiation_loop.py
@src/negotiation/llm/models.py
@src/negotiation/slack/triggers.py
@src/negotiation/slack/takeover.py
@src/negotiation/slack/client.py
@src/negotiation/slack/blocks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SlackDispatcher orchestrating pre-check, negotiation, and dispatch</name>
  <files>
    src/negotiation/slack/dispatcher.py
    src/negotiation/slack/__init__.py
  </files>
  <action>
    1. Create `src/negotiation/slack/dispatcher.py` with `SlackDispatcher` class:

       **Constructor `__init__(self, notifier, thread_state_manager, triggers_config, agent_email)`:**
       - Store `SlackNotifier`, `ThreadStateManager`, `EscalationTriggersConfig`, and `agent_email: str`.

       **Method `pre_check(self, email_body, thread_id, influencer_email, proposed_cpm, intent_confidence, gmail_service, anthropic_client) -> dict[str, Any] | None`:**
       This runs BEFORE `process_influencer_reply`. Returns an action dict if processing should stop, or None if negotiation loop should proceed.

       Steps:
       1. Check human takeover via `self._thread_state.is_human_managed(thread_id)`. If True, return `{"action": "skip", "reason": "Thread is human-managed"}`. Silent -- no Slack notification per locked decision.
       2. Check human reply detection via `detect_human_reply(gmail_service, thread_id, self._agent_email, influencer_email)`. If True, auto-claim the thread (`self._thread_state.claim_thread(thread_id, "auto-detected")`), return `{"action": "skip", "reason": "Human reply detected in thread"}`.
       3. Evaluate triggers via `evaluate_triggers(email_body, proposed_cpm, intent_confidence, self._triggers_config, anthropic_client)`. If any triggers fired, build escalation payload with trigger info and return `{"action": "escalate", "triggers": fired_triggers, "reason": first trigger's reason}`.
       4. Return None (proceed with negotiation loop).

       **Method `dispatch_escalation(self, payload: EscalationPayload) -> str`:**
       - Build blocks via `build_escalation_blocks(...)` using payload fields.
       - Construct `details_link` as Gmail thread permalink: `f"https://mail.google.com/mail/u/0/#inbox/{payload.thread_id}"`.
       - Build fallback text: `f"Escalation: {payload.influencer_name} - {payload.reason}"`.
       - Post via `self._notifier.post_escalation(blocks, fallback_text)`.
       - Return the message timestamp.

       **Method `dispatch_agreement(self, payload: AgreementPayload) -> str`:**
       - Build blocks via `build_agreement_blocks(...)` using payload fields.
       - Build fallback text: `f"Deal Agreed: {payload.influencer_name} - ${payload.agreed_rate:,.2f}"`.
       - Post via `self._notifier.post_agreement(blocks, fallback_text)`.
       - Return the message timestamp.

       **Method `handle_negotiation_result(self, result: dict[str, Any], negotiation_context: dict[str, Any]) -> dict[str, Any]`:**
       Takes the action dict from `process_influencer_reply` and dispatches to Slack as needed.
       - If `result["action"] == "escalate"`:
         - Build `EscalationPayload` from result data + negotiation_context. Populate Phase 4 fields:
           - `influencer_email` from `negotiation_context.get("influencer_email", "")`
           - `client_name` from `negotiation_context.get("client_name", "")`
           - `evidence_quote` from `result.get("triggers", [{}])[0].evidence` if available
           - `suggested_actions` based on escalation reason (e.g., CPM over threshold -> ["Reply with counter at $X", "Approve the proposed rate"])
           - `trigger_type` from first trigger type if available
         - Call `self.dispatch_escalation(payload)`.
         - Add `"slack_ts"` to result dict.
       - If `result["action"] == "accept"`:
         - Build `AgreementPayload` from classification + negotiation_context. Populate:
           - `agreed_rate` from classification.proposed_rate or negotiation_context
           - `platform`, `deliverables` from context
           - `cpm_achieved` calculated from agreed_rate / average_views * 1000
           - `next_steps` default: ["Send contract", "Confirm deliverables", "Schedule content calendar"]
           - `mention_users` from config or context
         - Call `self.dispatch_agreement(payload)`.
         - Add `"slack_ts"` to result dict.
       - Return the (potentially enriched) result dict.

    2. Update `src/negotiation/slack/__init__.py` to export `SlackDispatcher`.

    3. Run `uv run ruff check src/negotiation/slack/dispatcher.py --fix`.
    4. Run `uv run mypy src/negotiation/slack/dispatcher.py`.
  </action>
  <verify>
    `uv run ruff check src/negotiation/slack/dispatcher.py` -- no lint errors.
    `uv run mypy src/negotiation/slack/dispatcher.py` -- no type errors.
    `uv run python -c "from negotiation.slack import SlackDispatcher; print('Dispatcher imports OK')"` -- export works.
  </verify>
  <done>
    SlackDispatcher orchestrates the full Phase 4 flow: pre_check runs human takeover detection and trigger evaluation before the negotiation loop; handle_negotiation_result dispatches escalation and agreement actions to Slack with full Block Kit messages. All required fields from locked decisions are populated in the payloads.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for the dispatch pipeline</name>
  <files>
    tests/slack/test_dispatcher.py
  </files>
  <action>
    1. Create `tests/slack/test_dispatcher.py` with integration tests using mocked Slack and Gmail:

       **Fixtures:**
       - `mock_notifier`: MagicMock SlackNotifier with post_escalation/post_agreement returning "ts" strings.
       - `thread_state`: Real ThreadStateManager instance.
       - `triggers_config`: Real EscalationTriggersConfig with defaults.
       - `dispatcher`: SlackDispatcher with mock_notifier, thread_state, triggers_config.
       - `negotiation_context`: Dict with influencer_name, influencer_email, client_name, thread_id, platform, average_views, etc.

       **pre_check tests:**
       - Test returns skip action when thread is human-managed (via thread_state.claim_thread)
       - Test returns skip action when human reply detected in Gmail thread (mock gmail service)
       - Test returns escalate action when CPM trigger fires (proposed_cpm > 30.0)
       - Test returns None when no triggers fire and thread is agent-managed
       - Test auto-claims thread when human reply detected (is_human_managed becomes True)
       - Test skips LLM triggers when all 3 LLM triggers are disabled in config

       **dispatch_escalation tests:**
       - Test posts to escalation channel with correct blocks
       - Test includes all required fields in blocks (name, email, client, reason, evidence, rates, actions, link)
       - Test constructs Gmail permalink from thread_id
       - Test returns message timestamp

       **dispatch_agreement tests:**
       - Test posts to agreement channel with correct blocks
       - Test includes all required fields (name, email, client, rate, platform, deliverables, CPM, next steps)
       - Test includes @ mentions when mention_users provided
       - Test returns message timestamp

       **handle_negotiation_result tests:**
       - Test escalation result dispatches to Slack and adds slack_ts to result
       - Test accept result dispatches agreement to Slack and adds slack_ts to result
       - Test send result passes through without Slack dispatch
       - Test reject result passes through without Slack dispatch
       - Test escalation payload includes Phase 4 fields (influencer_email, client_name, trigger_type)

    2. Run `uv run ruff check tests/slack/test_dispatcher.py --fix`.
    3. Run `uv run pytest tests/slack/test_dispatcher.py -v`.
    4. Run `uv run pytest` -- full suite passes (no regressions).
  </action>
  <verify>
    `uv run pytest tests/slack/test_dispatcher.py -v` -- all dispatch tests pass.
    `uv run pytest tests/slack/ -v` -- all slack tests pass.
    `uv run pytest` -- full suite passes (no regressions from any phase).
    `uv run ruff check tests/slack/` -- no lint errors.
  </verify>
  <done>
    Integration tests verify the complete Phase 4 pipeline: pre-check gates (human takeover, triggers), escalation dispatch with all required Block Kit fields, agreement dispatch with deal summary and mentions, and handle_negotiation_result wiring. All tests pass with mocked Slack client and Gmail API.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/slack/ -v` -- all Phase 4 tests pass (blocks, client, triggers, takeover, commands, dispatcher)
2. `uv run pytest` -- complete test suite passes across all phases
3. `uv run ruff check src/negotiation/ tests/` -- no lint errors
4. `uv run mypy src/negotiation/` -- no type errors
5. `uv run python -c "from negotiation.slack import SlackDispatcher, SlackNotifier, ThreadStateManager, detect_human_reply, evaluate_triggers, build_escalation_blocks, build_agreement_blocks; print('All Phase 4 exports OK')"` -- complete package exports work
</verification>

<success_criteria>
- Pre-check gate stops processing for human-managed threads (silent)
- Pre-check gate auto-detects human replies in Gmail threads
- Pre-check gate fires escalation triggers before negotiation loop runs
- Escalation dispatch sends Block Kit message with all locked-decision required fields to escalation channel
- Agreement dispatch sends Block Kit message with deal summary and @ mentions to agreement channel
- handle_negotiation_result correctly routes escalate/accept/send/reject actions
- Full test suite passes across all 4 phases (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-slack-and-human-in-the-loop/04-04-SUMMARY.md`
</output>
