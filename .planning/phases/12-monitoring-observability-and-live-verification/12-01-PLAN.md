---
phase: 12-monitoring-observability-and-live-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/negotiation/observability/__init__.py
  - src/negotiation/observability/metrics.py
  - src/negotiation/observability/sentry.py
  - src/negotiation/observability/middleware.py
  - src/negotiation/config.py
  - src/negotiation/app.py
  - pyproject.toml
  - tests/test_metrics.py
  - tests/test_request_id.py
  - tests/test_sentry.py
autonomous: true
requirements:
  - OBS-03
  - OBS-04
  - OBS-05

must_haves:
  truths:
    - "GET /metrics returns Prometheus-format text with http_request_duration_seconds and http_requests_total metrics"
    - "GET /metrics includes custom gauges negotiation_active_total and counter negotiation_deals_closed_total"
    - "Every HTTP request receives a unique X-Request-ID response header"
    - "All structlog log entries for a request include the same request_id field"
    - "Unhandled exceptions are captured by Sentry with structlog context fields attached"
    - "Sentry is a no-op when sentry_dsn is empty (no crash, no network calls)"
  artifacts:
    - path: "src/negotiation/observability/metrics.py"
      provides: "Prometheus instrumentator setup and custom business metrics"
      exports: ["setup_metrics", "ACTIVE_NEGOTIATIONS", "DEALS_CLOSED"]
    - path: "src/negotiation/observability/sentry.py"
      provides: "Sentry SDK initialization with structlog-sentry bridge"
      exports: ["init_sentry"]
    - path: "src/negotiation/observability/middleware.py"
      provides: "Request ID middleware using structlog contextvars"
      exports: ["RequestIdMiddleware"]
    - path: "src/negotiation/config.py"
      provides: "New settings fields: sentry_dsn, enable_metrics"
      contains: "sentry_dsn"
  key_links:
    - from: "src/negotiation/app.py"
      to: "src/negotiation/observability/metrics.py"
      via: "setup_metrics(app) in create_app"
      pattern: "setup_metrics\\(.*app"
    - from: "src/negotiation/app.py"
      to: "src/negotiation/observability/sentry.py"
      via: "init_sentry(dsn) in main or configure_logging"
      pattern: "init_sentry"
    - from: "src/negotiation/app.py"
      to: "src/negotiation/observability/middleware.py"
      via: "app.add_middleware(RequestIdMiddleware)"
      pattern: "RequestIdMiddleware"
    - from: "src/negotiation/observability/sentry.py"
      to: "structlog processor chain"
      via: "SentryProcessor inserted before renderer"
      pattern: "SentryProcessor"
---

<objective>
Add Prometheus metrics endpoint, Sentry error reporting with structlog bridge, and request ID tracing middleware to the negotiation agent.

Purpose: Make the agent observable in production -- operators can scrape /metrics for dashboards, errors auto-report to Sentry with full context, and every log line is traceable to its originating HTTP request.

Output: Three observability modules (metrics, sentry, middleware) wired into the FastAPI app, with unit tests validating each.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-monitoring-observability-and-live-verification/12-RESEARCH.md
@src/negotiation/app.py
@src/negotiation/config.py
@src/negotiation/health.py
@tests/conftest.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create observability modules and update config/dependencies</name>
  <files>
    src/negotiation/observability/__init__.py
    src/negotiation/observability/metrics.py
    src/negotiation/observability/sentry.py
    src/negotiation/observability/middleware.py
    src/negotiation/config.py
    pyproject.toml
  </files>
  <action>
    1. Add new dependencies to pyproject.toml `dependencies` list:
       - `"prometheus-fastapi-instrumentator>=7.1.0"`
       - `"sentry-sdk>=2.53.0"`
       - `"structlog-sentry>=2.2.1"`

    2. Add two new fields to `Settings` in `src/negotiation/config.py`:
       ```python
       # -- Observability (Phase 12) -------------------------------------------
       sentry_dsn: str = ""                    # Empty = Sentry disabled
       enable_metrics: bool = True             # Toggle Prometheus /metrics
       ```

    3. Create `src/negotiation/observability/__init__.py` (empty or with brief docstring).

    4. Create `src/negotiation/observability/metrics.py`:
       - Import `Gauge`, `Counter` from `prometheus_client`
       - Import `Instrumentator` from `prometheus_fastapi_instrumentator`
       - Define module-level:
         - `ACTIVE_NEGOTIATIONS = Gauge("negotiation_active_total", "Number of currently active (non-terminal) negotiations")`
         - `DEALS_CLOSED = Counter("negotiation_deals_closed_total", "Total number of negotiations reaching AGREED state")`
       - Define `setup_metrics(app: FastAPI) -> None`:
         - Create `Instrumentator(should_group_status_codes=True, should_ignore_untemplated=True, excluded_handlers=["/health", "/ready", "/metrics"])`
         - Call `.instrument(app).expose(app, include_in_schema=False, should_gzip=True)`
       - NOTE: Business metrics are updated at state transitions, NOT by polling SQLite on scrape.

    5. Create `src/negotiation/observability/sentry.py`:
       - Import `sentry_sdk`, `LoggingIntegration` from `sentry_sdk.integrations.logging`
       - Define `init_sentry(dsn: str) -> None`:
         - If `not dsn`: return immediately (no-op when DSN is empty)
         - Call `sentry_sdk.init(dsn=dsn, traces_sample_rate=0.1, send_default_pii=False, integrations=[LoggingIntegration(event_level=None, level=None)])`
         - The `LoggingIntegration(event_level=None, level=None)` disables Sentry's default logging capture to prevent double-reporting with structlog-sentry.
       - Define `get_sentry_processor() -> structlog.types.Processor`:
         - Returns `SentryProcessor(event_level=logging.ERROR)` from `structlog_sentry`
         - This processor will be inserted into the structlog chain by app.py

    6. Create `src/negotiation/observability/middleware.py`:
       - Import `uuid`, `BaseHTTPMiddleware`, `RequestResponseEndpoint`, `Request`, `Response` from starlette, `structlog`
       - Define `RequestIdMiddleware(BaseHTTPMiddleware)`:
         - `async def dispatch(self, request, call_next)`:
           - `request_id = request.headers.get("X-Request-ID") or str(uuid.uuid4())`
           - `structlog.contextvars.clear_contextvars()`
           - `structlog.contextvars.bind_contextvars(request_id=request_id, service="negotiation-agent")`
           - `response = await call_next(request)`
           - `response.headers["X-Request-ID"] = request_id`
           - `return response`

    Run `uv sync` after updating pyproject.toml to install new dependencies.
  </action>
  <verify>
    - `python -c "from negotiation.observability.metrics import setup_metrics, ACTIVE_NEGOTIATIONS, DEALS_CLOSED; print('metrics OK')"` succeeds
    - `python -c "from negotiation.observability.sentry import init_sentry, get_sentry_processor; print('sentry OK')"` succeeds
    - `python -c "from negotiation.observability.middleware import RequestIdMiddleware; print('middleware OK')"` succeeds
    - `python -c "from negotiation.config import Settings; s = Settings(); print(s.sentry_dsn, s.enable_metrics)"` shows empty string and True
  </verify>
  <done>
    Three observability modules importable with correct exports. Settings has sentry_dsn and enable_metrics fields. New pip dependencies installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire observability into app.py and add unit tests</name>
  <files>
    src/negotiation/app.py
    tests/test_metrics.py
    tests/test_request_id.py
    tests/test_sentry.py
  </files>
  <action>
    1. Update `configure_logging()` in `src/negotiation/app.py`:
       - Accept optional `sentry_dsn: str = ""` parameter
       - If `sentry_dsn` is truthy, call `init_sentry(sentry_dsn)` from `negotiation.observability.sentry`
       - Insert `get_sentry_processor()` into `shared_processors` list AFTER `add_log_level` and BEFORE `TimeStamper` (critical placement per research -- SentryProcessor must receive structured dicts, not formatted strings)
       - Only add SentryProcessor when `sentry_dsn` is truthy

    2. Update `create_app()` in `src/negotiation/app.py`:
       - After `register_health_routes(app)`, conditionally call `setup_metrics(fastapi_app)` if `services["_settings"].enable_metrics` is True
       - Add `fastapi_app.add_middleware(RequestIdMiddleware)` (import from `negotiation.observability.middleware`)
       - Middleware must be added BEFORE instrumentator so request_id is available in all logs during instrumented requests

    3. Update `main()` in `src/negotiation/app.py`:
       - Pass `sentry_dsn=settings.sentry_dsn` to `configure_logging(production=settings.production, sentry_dsn=settings.sentry_dsn)`

    4. Create `tests/test_metrics.py`:
       - Use `fastapi.testclient.TestClient` with a minimal FastAPI app
       - Test: `GET /metrics` returns 200 with content containing `http_request` and `negotiation_active_total` and `negotiation_deals_closed_total`
       - Test: `/health` and `/ready` do NOT appear in metrics output (excluded_handlers works)
       - Use `prometheus_client.REGISTRY` cleanup in fixtures to avoid collector-already-registered errors between tests

    5. Create `tests/test_request_id.py`:
       - Test: Response has `X-Request-ID` header with UUID format when no client header sent
       - Test: When client sends `X-Request-ID: test-123`, response echoes `X-Request-ID: test-123`
       - Use TestClient with a minimal FastAPI app + RequestIdMiddleware

    6. Create `tests/test_sentry.py`:
       - Test: `init_sentry("")` does not raise (no-op path)
       - Test: `get_sentry_processor()` returns a callable (SentryProcessor instance)
       - Mock `sentry_sdk.init` to verify it is called with correct params when DSN is provided
       - Test: `init_sentry("https://examplePublicKey@o0.ingest.sentry.io/0")` calls `sentry_sdk.init` with `send_default_pii=False`

    Run `pytest tests/test_metrics.py tests/test_request_id.py tests/test_sentry.py -v` to verify all pass.
  </action>
  <verify>
    - `pytest tests/test_metrics.py tests/test_request_id.py tests/test_sentry.py -v` all pass
    - `pytest tests/ -v` full suite still passes (no regressions)
    - `ruff check src/negotiation/observability/ tests/test_metrics.py tests/test_request_id.py tests/test_sentry.py` no lint errors
  </verify>
  <done>
    Observability wired into the application. GET /metrics returns Prometheus-format text with HTTP metrics and custom business metrics. Every request gets X-Request-ID header and request_id in logs. Sentry initialized when DSN is configured. All unit tests pass.
  </done>
</task>

</tasks>

<verification>
1. Start the app (or use TestClient) and verify `GET /metrics` returns text with `http_request_duration_seconds`, `negotiation_active_total`, `negotiation_deals_closed_total`
2. Make several requests and verify `/metrics` shows incrementing counters
3. Send a request without `X-Request-ID` header -- response has auto-generated UUID in `X-Request-ID`
4. Send a request with `X-Request-ID: custom-123` -- response echoes it back
5. Verify `init_sentry("")` is a safe no-op (no network calls, no errors)
6. `pytest tests/ -v` -- all tests pass including new observability tests
7. `ruff check src/ tests/` -- no lint errors
</verification>

<success_criteria>
- GET /metrics returns Prometheus-format text with both HTTP and custom business metrics
- X-Request-ID header present on every response (auto-generated or echoed from client)
- Sentry SDK initialized only when sentry_dsn is non-empty
- SentryProcessor placed correctly in structlog chain (after add_log_level, before renderer)
- All existing tests continue to pass
- New unit tests for metrics, request ID, and Sentry all pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-monitoring-observability-and-live-verification/12-01-SUMMARY.md`
</output>
