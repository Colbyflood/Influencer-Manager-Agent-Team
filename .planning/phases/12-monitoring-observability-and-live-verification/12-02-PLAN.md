---
phase: 12-monitoring-observability-and-live-verification
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/conftest.py
  - tests/live/__init__.py
  - tests/live/conftest.py
  - tests/live/test_gmail_live.py
  - tests/live/test_sheets_live.py
  - tests/live/test_slack_live.py
autonomous: true
requirements:
  - CONFIG-02

must_haves:
  truths:
    - "Running pytest without --live skips all tests marked @pytest.mark.live"
    - "Running pytest --live executes live tests that call real Gmail, Sheets, and Slack APIs"
    - "Live Gmail test verifies send and receive of a real email"
    - "Live Sheets test verifies reading data from a real Google Sheet"
    - "Live Slack test verifies posting a message to a real Slack channel"
    - "Live tests read credentials from environment variables (same names as production config)"
  artifacts:
    - path: "tests/conftest.py"
      provides: "pytest_addoption(--live), pytest_configure (marker registration), pytest_collection_modifyitems (skip logic)"
      contains: "pytest.mark.live"
    - path: "tests/live/conftest.py"
      provides: "Fixtures for real service clients (gmail_client, sheets_client, slack_notifier)"
      contains: "gmail_client"
    - path: "tests/live/test_gmail_live.py"
      provides: "Live Gmail send/receive test"
      contains: "@pytest.mark.live"
    - path: "tests/live/test_sheets_live.py"
      provides: "Live Sheets read test"
      contains: "@pytest.mark.live"
    - path: "tests/live/test_slack_live.py"
      provides: "Live Slack message test"
      contains: "@pytest.mark.live"
  key_links:
    - from: "tests/conftest.py"
      to: "pytest CLI"
      via: "pytest_addoption --live flag"
      pattern: "addoption.*--live"
    - from: "tests/live/conftest.py"
      to: "negotiation.config.Settings"
      via: "fixtures read env vars via Settings"
      pattern: "Settings|get_settings"
---

<objective>
Add opt-in live integration tests that verify real Gmail, Sheets, and Slack connections using @pytest.mark.live.

Purpose: Provide a way to verify that the agent can actually communicate with external services using real credentials, without running these tests in normal CI (where they would fail or cause side effects).

Output: pytest --live marker infrastructure and three live test files covering Gmail send/receive, Sheets read, and Slack message delivery.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-monitoring-observability-and-live-verification/12-RESEARCH.md
@src/negotiation/config.py
@src/negotiation/email/client.py
@src/negotiation/sheets/client.py
@src/negotiation/slack/client.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up pytest live marker infrastructure and live test fixtures</name>
  <files>
    tests/conftest.py
    tests/live/__init__.py
    tests/live/conftest.py
  </files>
  <action>
    1. Update `tests/conftest.py` to add the live marker infrastructure. Add these three functions (keep existing fixtures intact):

       ```python
       def pytest_addoption(parser):
           parser.addoption(
               "--live", action="store_true", default=False,
               help="run live integration tests that require real service credentials",
           )

       def pytest_configure(config):
           config.addinivalue_line(
               "markers",
               "live: mark test as live integration test (requires real credentials, skipped by default)",
           )

       def pytest_collection_modifyitems(config, items):
           if config.getoption("--live"):
               return  # Run all tests including live
           skip_live = pytest.mark.skip(reason="need --live option to run")
           for item in items:
               if "live" in item.keywords:
                   item.add_marker(skip_live)
       ```

    2. Create `tests/live/__init__.py` (empty file).

    3. Create `tests/live/conftest.py` with fixtures for real service clients:

       - `gmail_client` fixture: Import `Settings` from `negotiation.config`, construct `Settings()` to read env vars. If `settings.gmail_token_path.exists()` is False, `pytest.skip("Gmail token not available")`. Otherwise, use `get_gmail_service()` and `GmailClient(service, settings.agent_email)` to create a real client. Return it.

       - `sheets_client` fixture: Read `settings.google_sheets_key` and `settings.sheets_service_account_path`. If either is empty/missing, `pytest.skip("Sheets credentials not available")`. Otherwise, use `get_sheets_client()` and `SheetsClient(gc, sheets_key)`. Return it.

       - `slack_notifier` fixture: Read `settings.slack_bot_token.get_secret_value()`. If empty, `pytest.skip("Slack bot token not available")`. Otherwise, create `SlackNotifier(escalation_channel=settings.slack_escalation_channel, agreement_channel=settings.slack_agreement_channel, bot_token=token)`. Return it.

       - `agent_email` fixture: Return `Settings().agent_email`. Skip if empty.

       All fixtures should have `scope="session"` to avoid re-creating clients per test.
  </action>
  <verify>
    - `pytest tests/live/ --collect-only` shows collected tests with "live" marker
    - `pytest tests/live/ -v` shows all live tests SKIPPED with reason "need --live option to run"
    - `pytest tests/ -v` still passes all existing tests (live tests skipped)
  </verify>
  <done>
    pytest --live infrastructure is in place. Running pytest without --live skips all live tests. Live test fixtures are configured to create real service clients from environment variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write live integration tests for Gmail, Sheets, and Slack</name>
  <files>
    tests/live/test_gmail_live.py
    tests/live/test_sheets_live.py
    tests/live/test_slack_live.py
  </files>
  <action>
    1. Create `tests/live/test_gmail_live.py`:
       - All tests decorated with `@pytest.mark.live`
       - `test_gmail_send_and_receive(gmail_client, agent_email)`:
         - Create a unique subject with timestamp to identify the test email
         - Use `gmail_client.send(OutboundEmail(to=agent_email, subject=unique_subject, body="Live test email"))` to send to self
         - Wait briefly (sleep 2-3 seconds) for delivery
         - Use `gmail_client.search(f"subject:{unique_subject}")` or equivalent to find the sent message
         - Assert the message was sent successfully (send returns a dict with "id" and "threadId")
       - `test_gmail_watch_setup(gmail_client)`:
         - Only run if `GMAIL_PUBSUB_TOPIC` env var is set, otherwise `pytest.skip`
         - Call `gmail_client.setup_watch(topic)` and assert result contains "historyId" and "expiration"

    2. Create `tests/live/test_sheets_live.py`:
       - All tests decorated with `@pytest.mark.live`
       - `test_sheets_read(sheets_client)`:
         - Call `sheets_client.get_all_records()` or the appropriate read method
         - Assert the result is a list (may be empty, but should not error)
         - Assert no exception was raised (proves authentication and sheet access work)

    3. Create `tests/live/test_slack_live.py`:
       - All tests decorated with `@pytest.mark.live`
       - `test_slack_post_message(slack_notifier)`:
         - Use the escalation channel (or a test channel if configured)
         - Post a test message: `slack_notifier.notify_escalation(...)` or use the underlying `_client.chat_postMessage(channel=..., text="[LIVE TEST] ...")`
         - Assert the API response indicates success (response["ok"] is True)
       - NOTE: Use a clearly identifiable test message prefix "[LIVE TEST]" so operators know it is automated

    Important: Each test file must be self-contained. Tests should not depend on each other. Each test should handle its own setup and verify a single behavior. Use descriptive assertion messages.
  </action>
  <verify>
    - `pytest tests/live/ --collect-only` lists all live tests
    - `pytest tests/ -v` passes with live tests shown as SKIPPED
    - `pytest tests/live/ --live -v` (with real credentials in env) runs and passes all live tests
    - `ruff check tests/live/` no lint errors
  </verify>
  <done>
    Three live test files exist covering Gmail send/receive, Sheets read, and Slack message delivery. All tests are skipped by default and only run with --live flag. Tests use real credentials from environment variables.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -v` -- all existing tests pass, live tests show as SKIPPED
2. `pytest tests/live/ --collect-only` -- all live tests collected
3. `pytest tests/ -k "not live" -v` -- no live tests appear
4. With real credentials: `pytest tests/live/ --live -v` -- all live tests pass
5. `ruff check tests/` -- no lint errors
</verification>

<success_criteria>
- @pytest.mark.live marker registered and functional
- pytest without --live skips all live tests with clear reason message
- pytest --live executes live tests
- Live Gmail test verifies real send operation
- Live Sheets test verifies real read operation
- Live Slack test verifies real message delivery
- All credentials sourced from environment variables (not hardcoded)
- No live tests run in normal CI
</success_criteria>

<output>
After completion, create `.planning/phases/12-monitoring-observability-and-live-verification/12-02-SUMMARY.md`
</output>
