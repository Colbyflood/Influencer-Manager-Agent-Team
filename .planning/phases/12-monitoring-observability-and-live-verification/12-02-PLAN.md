---
phase: 12-monitoring-observability-and-live-verification
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - tests/live/__init__.py
  - tests/live/conftest.py
  - tests/live/test_gmail_live.py
  - tests/live/test_sheets_live.py
  - tests/live/test_slack_live.py
autonomous: true
requirements:
  - CONFIG-02

must_haves:
  truths:
    - "Running pytest (default) skips all tests marked @pytest.mark.live via addopts '-m not live'"
    - "Running pytest -m live executes live tests that call real Gmail, Sheets, and Slack APIs"
    - "Live Gmail test verifies send and receive of a real email"
    - "Live Sheets test verifies reading data from a real Google Sheet"
    - "Live Slack test verifies posting a message to a real Slack channel"
    - "Live tests read credentials from environment variables (same names as production config)"
  artifacts:
    - path: "pyproject.toml"
      provides: "Live marker registration and default exclusion via addopts '-m not live'"
      contains: "markers"
    - path: "tests/live/conftest.py"
      provides: "Fixtures for real service clients (gmail_client, sheets_client, slack_notifier)"
      contains: "gmail_client"
    - path: "tests/live/test_gmail_live.py"
      provides: "Live Gmail send/receive test"
      contains: "@pytest.mark.live"
    - path: "tests/live/test_sheets_live.py"
      provides: "Live Sheets read test"
      contains: "@pytest.mark.live"
    - path: "tests/live/test_slack_live.py"
      provides: "Live Slack message test"
      contains: "@pytest.mark.live"
  key_links:
    - from: "pyproject.toml"
      to: "pytest CLI"
      via: "addopts '-m not live' excludes live tests by default; 'pytest -m live' overrides"
      pattern: "not live"
    - from: "tests/live/conftest.py"
      to: "negotiation.config.Settings"
      via: "fixtures read env vars via Settings"
      pattern: "Settings|get_settings"
---

<objective>
Add opt-in live integration tests that verify real Gmail, Sheets, and Slack connections using @pytest.mark.live.

Purpose: Provide a way to verify that the agent can actually communicate with external services using real credentials, without running these tests in normal CI (where they would fail or cause side effects).

Output: pytest `-m live` marker infrastructure (via pyproject.toml) and three live test files covering Gmail send/receive, Sheets read, and Slack message delivery.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-monitoring-observability-and-live-verification/12-RESEARCH.md
@src/negotiation/config.py
@src/negotiation/email/client.py
@src/negotiation/sheets/client.py
@src/negotiation/slack/client.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up pytest live marker infrastructure and live test fixtures</name>
  <files>
    pyproject.toml
    tests/live/__init__.py
    tests/live/conftest.py
  </files>
  <action>
    1. Update `pyproject.toml` `[tool.pytest.ini_options]` section to register the `live` marker and exclude live tests by default:

       ```toml
       [tool.pytest.ini_options]
       testpaths = ["tests"]
       pythonpath = ["src"]
       addopts = "-v --tb=short -m 'not live'"
       markers = [
           "live: mark test as live integration test (requires real credentials, skipped by default)",
       ]
       ```

       **Key behavior:** The `addopts = "-v --tb=short -m 'not live'"` causes `pytest` (with no args) to exclude all `@pytest.mark.live` tests. Running `pytest -m live` overrides `addopts` marker expression to select ONLY live tests (pytest uses the last `-m` on the command line). This matches the ROADMAP success criterion: "Running `pytest -m live`".

       **Do NOT add** any `pytest_addoption`, `pytest_configure`, or `pytest_collection_modifyitems` hooks to `tests/conftest.py` for this purpose -- the native marker approach via pyproject.toml handles everything.

    2. Create `tests/live/__init__.py` (empty file).

    3. Create `tests/live/conftest.py` with fixtures for real service clients:

       - `gmail_client` fixture: Import `Settings` from `negotiation.config`, construct `Settings()` to read env vars. If `settings.gmail_token_path.exists()` is False, `pytest.skip("Gmail token not available")`. Otherwise, use `get_gmail_service()` and `GmailClient(service, settings.agent_email)` to create a real client. Return it.

       - `sheets_client` fixture: Read `settings.google_sheets_key` and `settings.sheets_service_account_path`. If either is empty/missing, `pytest.skip("Sheets credentials not available")`. Otherwise, use `get_sheets_client()` and `SheetsClient(gc, sheets_key)`. Return it.

       - `slack_notifier` fixture: Read `settings.slack_bot_token.get_secret_value()`. If empty, `pytest.skip("Slack bot token not available")`. Otherwise, create `SlackNotifier(escalation_channel=settings.slack_escalation_channel, agreement_channel=settings.slack_agreement_channel, bot_token=token)`. Return it.

       - `agent_email` fixture: Return `Settings().agent_email`. Skip if empty.

       All fixtures should have `scope="session"` to avoid re-creating clients per test.
  </action>
  <verify>
    - `pytest tests/live/ --collect-only -m live` shows collected tests with "live" marker
    - `pytest tests/ -v` still passes all existing tests (live tests excluded via default addopts)
    - `pytest -m live --collect-only` collects live tests (overrides default marker expression)
  </verify>
  <done>
    Native pytest marker infrastructure is in place via pyproject.toml. Running `pytest` excludes live tests by default. Running `pytest -m live` selects and executes live tests. No custom CLI options or collection hooks needed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write live integration tests for Gmail, Sheets, and Slack</name>
  <files>
    tests/live/test_gmail_live.py
    tests/live/test_sheets_live.py
    tests/live/test_slack_live.py
  </files>
  <action>
    1. Create `tests/live/test_gmail_live.py`:
       - All tests decorated with `@pytest.mark.live`
       - `test_gmail_send_and_receive(gmail_client, agent_email)`:
         - Create a unique subject with timestamp to identify the test email
         - Use `gmail_client.send(OutboundEmail(to=agent_email, subject=unique_subject, body="Live test email"))` to send to self
         - Wait briefly (sleep 2-3 seconds) for delivery
         - Use `gmail_client.search(f"subject:{unique_subject}")` or equivalent to find the sent message
         - Assert the message was sent successfully (send returns a dict with "id" and "threadId")
       - `test_gmail_watch_setup(gmail_client)`:
         - Only run if `GMAIL_PUBSUB_TOPIC` env var is set, otherwise `pytest.skip`
         - Call `gmail_client.setup_watch(topic)` and assert result contains "historyId" and "expiration"

    2. Create `tests/live/test_sheets_live.py`:
       - All tests decorated with `@pytest.mark.live`
       - `test_sheets_read(sheets_client)`:
         - Call `sheets_client.get_all_records()` or the appropriate read method
         - Assert the result is a list (may be empty, but should not error)
         - Assert no exception was raised (proves authentication and sheet access work)

    3. Create `tests/live/test_slack_live.py`:
       - All tests decorated with `@pytest.mark.live`
       - `test_slack_post_message(slack_notifier)`:
         - Use the escalation channel (or a test channel if configured)
         - Post a test message: `slack_notifier.notify_escalation(...)` or use the underlying `_client.chat_postMessage(channel=..., text="[LIVE TEST] ...")`
         - Assert the API response indicates success (response["ok"] is True)
       - NOTE: Use a clearly identifiable test message prefix "[LIVE TEST]" so operators know it is automated

    Important: Each test file must be self-contained. Tests should not depend on each other. Each test should handle its own setup and verify a single behavior. Use descriptive assertion messages.
  </action>
  <verify>
    - `pytest -m live --collect-only` lists all live tests
    - `pytest tests/ -v` passes with live tests excluded from collection
    - `pytest -m live -v` (with real credentials in env) runs and passes all live tests
    - `ruff check tests/live/` no lint errors
  </verify>
  <done>
    Three live test files exist covering Gmail send/receive, Sheets read, and Slack message delivery. All tests are excluded by default (via addopts `-m 'not live'`) and only run with `pytest -m live`. Tests use real credentials from environment variables.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -v` -- all existing tests pass, live tests excluded (not collected, not skipped -- completely absent from output)
2. `pytest -m live --collect-only` -- all live tests collected (overrides addopts)
3. With real credentials: `pytest -m live -v` -- all live tests run and pass
4. `ruff check tests/` -- no lint errors
5. `grep -q "not live" pyproject.toml` -- confirms marker exclusion in addopts
</verification>

<success_criteria>
- @pytest.mark.live marker registered in pyproject.toml markers list
- addopts includes `-m 'not live'` so default pytest run excludes live tests
- `pytest -m live` overrides default marker expression and runs live tests (matches ROADMAP criterion 4)
- Live Gmail test verifies real send operation
- Live Sheets test verifies real read operation
- Live Slack test verifies real message delivery
- All credentials sourced from environment variables (not hardcoded)
- No custom --live CLI option or pytest_collection_modifyitems hook exists
- No live tests run in normal CI
</success_criteria>

<output>
After completion, create `.planning/phases/12-monitoring-observability-and-live-verification/12-02-SUMMARY.md`
</output>
