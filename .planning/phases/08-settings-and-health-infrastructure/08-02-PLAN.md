---
phase: 08-settings-and-health-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - src/negotiation/health.py
  - src/negotiation/app.py
  - src/negotiation/campaign/webhook.py
  - tests/test_config.py
  - tests/test_health.py
autonomous: true
requirements:
  - OBS-01
  - OBS-02

must_haves:
  truths:
    - "GET /health returns 200 with {status: healthy} when the process is running"
    - "GET /ready returns 200 with {status: ready} when audit DB is writable and Gmail client is initialized"
    - "GET /ready returns 503 with {status: not_ready} and failing checks when audit DB or Gmail client is unavailable"
    - "The old /health endpoint on the webhook router is removed (no duplicate route)"
  artifacts:
    - path: "src/negotiation/health.py"
      provides: "register_health_routes() with /health and /ready endpoints"
      min_lines: 30
      exports: ["register_health_routes"]
    - path: "tests/test_health.py"
      provides: "Tests for /health 200, /ready 200, /ready 503 scenarios"
      min_lines: 40
    - path: "tests/test_config.py"
      provides: "Tests for Settings defaults, validate_credentials production/dev"
      min_lines: 40
  key_links:
    - from: "src/negotiation/app.py"
      to: "src/negotiation/health.py"
      via: "register_health_routes(app) call in create_app()"
      pattern: "register_health_routes"
    - from: "src/negotiation/health.py"
      to: "app.state.services"
      via: "request.app.state.services access in /ready"
      pattern: "request\\.app\\.state\\.services"
---

<objective>
Add /health and /ready observability endpoints and write tests for the full Phase 8 feature set.

Purpose: Make the agent's health externally observable for container orchestration (Docker HEALTHCHECK, load balancers). The /health endpoint confirms the process is alive (liveness). The /ready endpoint confirms dependencies are functional (readiness) -- checking the audit DB is writable and Gmail client is initialized. Tests verify all Phase 8 behavior: Settings defaults, credential validation, and both health endpoints.

Output: `src/negotiation/health.py` with health endpoints; `/health` removed from webhook router; tests for config and health.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-settings-and-health-infrastructure/08-RESEARCH.md
@.planning/phases/08-settings-and-health-infrastructure/08-01-SUMMARY.md
@src/negotiation/app.py
@src/negotiation/campaign/webhook.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health endpoints module and wire into app</name>
  <files>
    src/negotiation/health.py
    src/negotiation/app.py
    src/negotiation/campaign/webhook.py
  </files>
  <action>
1. Create `src/negotiation/health.py` with a `register_health_routes(app: FastAPI) -> None` function that registers two endpoints on the app:

   a. `GET /health` -- Liveness probe:
      - Returns `{"status": "healthy"}` with 200 status code
      - No checks needed -- if the process is running and handling HTTP, it's alive
      - This is intentionally trivial

   b. `GET /ready` -- Readiness probe:
      - Access `request.app.state.services` to check runtime dependencies
      - Check 1 (audit_db): Get `services["audit_conn"]`, execute `conn.execute("SELECT 1")` in a try/except. Set `checks["audit_db"] = "ok"` on success, `"fail"` on exception. Use `asyncio.to_thread()` for the SQLite call since it's blocking. Note: Do NOT use INSERT/DELETE for write check (research pitfall 3) -- SELECT 1 validates the connection is alive and file is accessible.
      - Check 2 (gmail): Check `services.get("gmail_client") is not None`. Set `checks["gmail"] = "ok"` if present, `"fail"` if None.
      - If all checks pass: return `JSONResponse(content={"status": "ready", "checks": checks}, status_code=200)`
      - If any check fails: return `JSONResponse(content={"status": "not_ready", "checks": checks}, status_code=503)`
      - Import `JSONResponse` from `fastapi.responses`

2. In `src/negotiation/campaign/webhook.py`:
   - Delete the entire `health_check()` function and its `@router.get("/health")` decorator (lines 124-131). This endpoint is being relocated to the top-level app via health.py.

3. In `src/negotiation/app.py` `create_app()` function:
   - Import `from negotiation.health import register_health_routes`
   - Call `register_health_routes(fastapi_app)` after `fastapi_app.include_router(webhook_router)` but before the gmail_notification endpoint definition
   - This ensures /health and /ready are top-level routes on the app, not on the webhook sub-router
  </action>
  <verify>
    - `ruff check src/negotiation/health.py src/negotiation/app.py src/negotiation/campaign/webhook.py` passes
    - `grep -n "health" src/negotiation/campaign/webhook.py` shows NO /health endpoint remaining
    - `grep -n "register_health_routes" src/negotiation/app.py` shows the import and call
    - `python -c "from negotiation.health import register_health_routes; print('OK')"` prints OK
  </verify>
  <done>
    /health and /ready endpoints exist as top-level app routes in health.py. The old /health on the webhook router is removed. create_app() calls register_health_routes().
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for Settings, credential validation, and health endpoints</name>
  <files>
    tests/test_config.py
    tests/test_health.py
  </files>
  <action>
1. Create `tests/test_config.py` with the following tests:

   a. `test_settings_defaults()`:
      - Instantiate `Settings(_env_file=None)` with no env vars to verify defaults.
      - Assert: `production is False`, `webhook_port == 8000`, `agent_email == ""`, `audit_db_path == Path("data/audit.db")`, `gmail_token_path == Path("token.json")`.
      - Use `_env_file=None` to skip loading any .env file during tests.

   b. `test_settings_from_env(monkeypatch)`:
      - Use `monkeypatch.setenv("PRODUCTION", "true")`, `monkeypatch.setenv("WEBHOOK_PORT", "9090")`, `monkeypatch.setenv("SLACK_BOT_TOKEN", "xoxb-test")`.
      - Instantiate `Settings(_env_file=None)`.
      - Assert: `production is True`, `webhook_port == 9090`, `slack_bot_token.get_secret_value() == "xoxb-test"`.

   c. `test_validate_credentials_production_missing(tmp_path, monkeypatch)`:
      - Create Settings with `production=True`, `gmail_token_path` pointing to non-existent file, empty slack tokens.
      - Call `validate_credentials(settings)` and assert it calls `sys.exit(1)`.
      - Use `monkeypatch.setattr("sys.exit", ...)` or `pytest.raises(SystemExit)`.

   d. `test_validate_credentials_production_valid(tmp_path)`:
      - Create a temp token.json and service_account.json in tmp_path.
      - Create Settings with `production=True`, valid paths, non-empty tokens.
      - Call `validate_credentials(settings)` -- should NOT raise or exit.

   e. `test_validate_credentials_dev_mode_warns(tmp_path, caplog)`:
      - Create Settings with `production=False`, missing credentials.
      - Call `validate_credentials(settings)` -- should NOT exit.
      - Verify warning messages were logged (check structlog output or caplog).

   f. `test_get_settings_cached()`:
      - Call `get_settings()` twice, verify same object (via `is` comparison).
      - Clear cache between test runs: `get_settings.cache_clear()` in a fixture.

2. Create `tests/test_health.py` with the following tests using FastAPI TestClient:

   a. `test_health_returns_200()`:
      - Create a minimal FastAPI app, register health routes, create TestClient.
      - GET /health -> assert status 200, body `{"status": "healthy"}`.

   b. `test_ready_returns_200_when_services_ok()`:
      - Create a FastAPI app with `app.state.services` containing a real SQLite in-memory connection (`sqlite3.connect(":memory:")`) and a mock gmail_client (any truthy object).
      - Register health routes, create TestClient.
      - GET /ready -> assert status 200, body has `"status": "ready"`, both checks "ok".

   c. `test_ready_returns_503_when_db_missing()`:
      - Create app with `app.state.services = {"audit_conn": None, "gmail_client": object()}`.
      - (Or use a closed connection that raises on execute.)
      - GET /ready -> assert status 503, body has `"status": "not_ready"`, `"audit_db": "fail"`.

   d. `test_ready_returns_503_when_gmail_missing()`:
      - Create app with valid audit_conn but `gmail_client: None`.
      - GET /ready -> assert status 503, `"gmail": "fail"`.

   e. `test_ready_returns_503_when_both_missing()`:
      - Both audit_conn broken and gmail_client None.
      - GET /ready -> assert status 503, both checks "fail".

   All tests should use `from fastapi.testclient import TestClient` and `import sqlite3` for the in-memory connection. No external dependencies needed.

3. Run `pytest tests/test_config.py tests/test_health.py -v` to verify all tests pass.
  </action>
  <verify>
    - `pytest tests/test_config.py tests/test_health.py -v` -- all tests pass
    - `ruff check tests/test_config.py tests/test_health.py` -- no lint errors
    - Test count: at least 10 tests total across both files
  </verify>
  <done>
    test_config.py has 6+ tests covering Settings defaults, env loading, credential validation (production fail, production pass, dev warn), and get_settings caching. test_health.py has 4+ tests covering /health 200, /ready 200, /ready 503 (db fail), /ready 503 (gmail fail). All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `curl http://localhost:8000/health` returns `{"status":"healthy"}` with HTTP 200 (when server is running)
2. `curl http://localhost:8000/ready` returns 200 or 503 depending on service availability
3. `grep -n "/health" src/negotiation/campaign/webhook.py` returns NO matches (old endpoint removed)
4. `pytest tests/test_config.py tests/test_health.py -v` -- all tests pass
5. `ruff check src/negotiation/ tests/` -- no lint errors
</verification>

<success_criteria>
- GET /health returns 200 with {"status": "healthy"} when process is alive
- GET /ready returns 200 only when audit DB is writable AND Gmail client is initialized
- GET /ready returns 503 with specific check failures when any dependency is unavailable
- Old /health endpoint removed from webhook router (no duplicate)
- All tests pass covering Settings, credential validation, /health, and /ready
</success_criteria>

<output>
After completion, create `.planning/phases/08-settings-and-health-infrastructure/08-02-SUMMARY.md`
</output>
