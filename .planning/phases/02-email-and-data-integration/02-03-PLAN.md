---
phase: 02-email-and-data-integration
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/negotiation/sheets/client.py
  - src/negotiation/sheets/__init__.py
  - tests/sheets/test_client.py
autonomous: true
requirements:
  - NEG-01
  - DATA-02

must_haves:
  truths:
    - "Agent can connect to a Google Sheet by spreadsheet key and read all influencer records"
    - "Agent can locate a specific influencer row by name (case-insensitive) and return their data as an InfluencerRow"
    - "Agent can convert an InfluencerRow to a PayRange for use by the pricing engine"
    - "Agent handles missing influencer gracefully with a clear error"
    - "Agent handles Google Sheets API errors (rate limiting, auth failures) without crashing"
  artifacts:
    - path: "src/negotiation/sheets/client.py"
      provides: "Google Sheets operations: connect, read all records, find influencer by name"
      exports: ["SheetsClient"]
  key_links:
    - from: "src/negotiation/sheets/client.py"
      to: "src/negotiation/auth/credentials.py"
      via: "Uses gspread client from get_sheets_client"
      pattern: "get_sheets_client|gspread"
    - from: "src/negotiation/sheets/client.py"
      to: "src/negotiation/sheets/models.py"
      via: "Returns InfluencerRow instances from sheet data"
      pattern: "InfluencerRow"
    - from: "src/negotiation/sheets/models.py"
      to: "src/negotiation/domain/models.py"
      via: "InfluencerRow.to_pay_range() returns PayRange"
      pattern: "PayRange"
---

<objective>
Implement the Google Sheets integration: connect to a spreadsheet, read influencer outreach data, and look up specific influencers by name to retrieve their pre-calculated pay ranges.

Purpose: The agent needs influencer data (metrics, pay ranges) from the team's Google Sheet before it can negotiate. This bridges the external data source to the domain pricing engine built in Phase 1.

Output: SheetsClient class wrapping gspread operations with InfluencerRow model integration, case-insensitive lookup, and error handling. All tested with mocked gspread responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-email-and-data-integration/02-RESEARCH.md
@.planning/phases/02-email-and-data-integration/02-01-SUMMARY.md
@src/negotiation/auth/credentials.py
@src/negotiation/sheets/models.py
@src/negotiation/domain/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SheetsClient with influencer lookup and full test coverage</name>
  <files>
    src/negotiation/sheets/client.py
    src/negotiation/sheets/__init__.py
    tests/sheets/test_client.py
  </files>
  <action>
    **src/negotiation/sheets/client.py:**
    Create a `SheetsClient` class that wraps gspread:

    ```python
    class SheetsClient:
        def __init__(self, gc: gspread.Client, spreadsheet_key: str):
            self._gc = gc
            self._spreadsheet_key = spreadsheet_key
            self._spreadsheet: gspread.Spreadsheet | None = None
    ```

    Methods:

    1. `_get_spreadsheet(self) -> gspread.Spreadsheet` -- Lazy-loads and caches the spreadsheet via `self._gc.open_by_key(self._spreadsheet_key)`. Returns cached instance on subsequent calls. This avoids re-opening on every read.

    2. `get_all_influencers(self, worksheet_name: str = "Sheet1") -> list[InfluencerRow]` -- Opens the specified worksheet (default "Sheet1"). Calls `worksheet.get_all_records()` in one API call (avoids rate limiting per research Pitfall 4). Maps each record dict to an `InfluencerRow` model. Returns list of all InfluencerRow instances. Skips rows with empty name fields (partial data). Raises `ValueError` with clear message if worksheet is empty or has no records.

    3. `find_influencer(self, name: str, worksheet_name: str = "Sheet1") -> InfluencerRow` -- Calls `get_all_influencers()` then filters by `name.strip().lower() == row.name.strip().lower()` (case-insensitive, whitespace-trimmed). Returns the first match. Raises `ValueError(f"Influencer '{name}' not found in sheet")` if no match. Follow research Pattern 5.

    4. `get_pay_range(self, name: str, worksheet_name: str = "Sheet1") -> PayRange` -- Convenience method. Calls `find_influencer(name)` then returns `influencer.to_pay_range()`. This is the primary method the negotiation pipeline will use.

    Also create a module-level factory function:
    5. `create_sheets_client(spreadsheet_key: str, service_account_path: str | None = None) -> SheetsClient` -- Creates a gspread client via `get_sheets_client(service_account_path)` from auth module, then returns `SheetsClient(gc, spreadsheet_key)`. This is the recommended constructor for production use.

    **src/negotiation/sheets/__init__.py:** Update to re-export SheetsClient, create_sheets_client, and InfluencerRow. Sort __all__ alphabetically per ruff RUF022.

    **Tests (tests/sheets/test_client.py):**
    Use `unittest.mock.patch` and `unittest.mock.MagicMock` to mock gspread.Client and worksheet objects.

    Create a fixture `sample_sheet_records` returning a list of dicts mimicking `get_all_records()` output:
    ```python
    [
        {"Name": "Creator A", "Email": "creatora@email.com", "Platform": "instagram", "Handle": "@creatora", "Average Views": 50000, "Min Rate": 1000.0, "Max Rate": 1500.0},
        {"Name": "Creator B", "Email": "creatorb@email.com", "Platform": "tiktok", "Handle": "@creatorb", "Average Views": 100000, "Min Rate": 2000.0, "Max Rate": 3000.0},
        {"Name": "Creator C", "Email": "creatorc@email.com", "Platform": "youtube", "Handle": "@creatorc", "Average Views": 200000, "Min Rate": 4000.0, "Max Rate": 6000.0},
    ]
    ```

    Test get_all_influencers:
    - Returns correct number of InfluencerRow instances
    - Correctly maps dict keys to model fields
    - Float values (Min Rate, Max Rate) are converted to Decimal
    - Skips rows with empty Name
    - Raises ValueError on empty worksheet

    Test find_influencer:
    - Finds influencer by exact name
    - Finds influencer case-insensitively ("creator a" matches "Creator A")
    - Finds influencer with leading/trailing whitespace
    - Raises ValueError when influencer not found

    Test get_pay_range:
    - Returns PayRange with correct min_rate, max_rate, average_views
    - PayRange min_rate and max_rate are Decimal, not float
    - Raises ValueError when influencer not found

    Test create_sheets_client:
    - Mock get_sheets_client and verify it creates SheetsClient correctly

    Test caching:
    - Verify _get_spreadsheet only opens once on multiple calls

    ~20-25 tests total.

    Run full test suite: `uv run pytest`, `uv run ruff check src/ tests/`, `uv run ruff format --check src/ tests/`, `uv run mypy src/`.
  </action>
  <verify>
    `uv run pytest` -- all tests pass (full suite including previous plans).
    `uv run ruff check src/ tests/` -- clean.
    `uv run ruff format --check src/ tests/` -- clean.
    `uv run mypy src/` -- clean.
  </verify>
  <done>
    SheetsClient.get_all_influencers reads all rows from sheet in one API call and returns InfluencerRow instances.
    SheetsClient.find_influencer locates an influencer by name (case-insensitive) or raises clear error.
    SheetsClient.get_pay_range bridges sheet data directly to the pricing engine's PayRange model.
    Float-to-Decimal coercion prevents precision errors from Google Sheets numeric values.
    Spreadsheet connection is cached to avoid redundant API calls.
    All tests pass with mocked gspread, linters clean, mypy clean.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "from negotiation.sheets import SheetsClient, create_sheets_client, InfluencerRow"` succeeds
2. `uv run pytest tests/sheets/ -v` -- all sheets tests pass
3. `uv run pytest` -- full suite passes
4. `uv run ruff check src/ tests/` -- clean
5. `uv run mypy src/` -- clean
</verification>

<success_criteria>
- SheetsClient wraps all 4 operations (get_all_influencers, find_influencer, get_pay_range, cached spreadsheet access)
- Factory function create_sheets_client handles auth and construction
- Case-insensitive influencer lookup with clear error messages
- Float-to-Decimal coercion verified end-to-end (sheet data -> InfluencerRow -> PayRange)
- All operations tested with mocked gspread (~20-25 new tests)
- Zero coupling to real Google Sheets credentials (all tests use mocks)
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-and-data-integration/02-03-SUMMARY.md`
</output>
