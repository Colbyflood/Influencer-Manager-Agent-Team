---
phase: 05-campaign-ingestion-and-operational-readiness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/negotiation/campaign/__init__.py
  - src/negotiation/campaign/models.py
  - src/negotiation/campaign/cpm_tracker.py
  - src/negotiation/audit/__init__.py
  - src/negotiation/audit/models.py
  - src/negotiation/audit/store.py
  - src/negotiation/resilience/__init__.py
  - src/negotiation/resilience/retry.py
  - config/campaign_fields.yaml
  - tests/campaign/test_models.py
  - tests/campaign/test_cpm_tracker.py
  - tests/audit/test_store.py
autonomous: true
requirements:
  - DATA-01
  - DATA-03

must_haves:
  truths:
    - "Campaign data model validates ClickUp-sourced fields (client name, budget, deliverables, influencer list, CPM range, platform, timeline)"
    - "CPM tracker calculates per-influencer flexibility considering both running campaign average AND engagement quality"
    - "SQLite audit store initializes with WAL mode, creates indexed audit_log table, and supports insert + query operations"
    - "Resilience retry decorator wraps API calls with 3 attempts, exponential backoff with jitter, and Slack error notification on final failure"
  artifacts:
    - path: "src/negotiation/campaign/models.py"
      provides: "Campaign, CampaignInfluencer, CampaignCPMRange Pydantic models"
      min_lines: 40
    - path: "src/negotiation/campaign/cpm_tracker.py"
      provides: "CampaignCPMTracker with engagement-quality-weighted CPM flexibility"
      min_lines: 60
    - path: "src/negotiation/audit/models.py"
      provides: "EventType StrEnum and AuditEntry Pydantic model"
      min_lines: 30
    - path: "src/negotiation/audit/store.py"
      provides: "init_audit_db, insert_audit_entry, query_audit_trail functions"
      min_lines: 80
    - path: "src/negotiation/resilience/retry.py"
      provides: "resilient_api_call decorator factory with Slack error notification"
      min_lines: 30
    - path: "config/campaign_fields.yaml"
      provides: "ClickUp custom field name to campaign model field mapping"
      min_lines: 10
  key_links:
    - from: "src/negotiation/campaign/models.py"
      to: "src/negotiation/domain/types.py"
      via: "imports Platform enum"
      pattern: "from negotiation\\.domain\\.types import.*Platform"
    - from: "src/negotiation/campaign/cpm_tracker.py"
      to: "src/negotiation/campaign/models.py"
      via: "uses CampaignCPMRange for target range"
      pattern: "CampaignCPMRange|target_min|target_max"
    - from: "src/negotiation/audit/store.py"
      to: "src/negotiation/audit/models.py"
      via: "accepts AuditEntry for insert"
      pattern: "AuditEntry"

user_setup:
  - service: clickup
    why: "Campaign data ingestion from ClickUp form submissions"
    env_vars:
      - name: CLICKUP_API_TOKEN
        source: "ClickUp Settings -> Apps -> Generate API Token (or use team/workspace token)"
      - name: CLICKUP_WEBHOOK_SECRET
        source: "Returned when webhook is created via ClickUp API (store securely)"
      - name: CLICKUP_TEAM_ID
        source: "ClickUp Settings -> Workspace (team ID in URL)"
    dashboard_config:
      - task: "Create a ClickUp List for campaign form submissions"
        location: "ClickUp workspace -> Space -> Create List"
      - task: "Create a ClickUp Form with custom fields: Client Name (text), Budget (currency), Target Deliverables (text), Influencer List (text), CPM Min (number), CPM Max (number), Platform (dropdown), Timeline (text)"
        location: "ClickUp List -> + View -> Form"
---

<objective>
Install Phase 5 dependencies and create foundation models, data stores, and resilience infrastructure for campaign ingestion and audit trail.

Purpose: All subsequent Phase 5 plans depend on these models, the SQLite audit store, the retry decorator, and the campaign field configuration. This plan creates the shared foundation that Plans 02-04 build upon.

Output: Campaign Pydantic models, CPM tracker with engagement-quality logic, SQLite audit store with WAL mode, tenacity-based retry decorator, and ClickUp field mapping config.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-campaign-ingestion-and-operational-readiness/05-RESEARCH.md

# Existing domain types this plan imports from
@src/negotiation/domain/types.py
@src/negotiation/domain/models.py

# Existing config pattern to follow
@config/escalation_triggers.yaml

# Existing Slack client for error notification in retry decorator
@src/negotiation/slack/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create campaign + audit models with CPM tracker</name>
  <files>
    pyproject.toml
    src/negotiation/campaign/__init__.py
    src/negotiation/campaign/models.py
    src/negotiation/campaign/cpm_tracker.py
    src/negotiation/audit/__init__.py
    src/negotiation/audit/models.py
    config/campaign_fields.yaml
    tests/campaign/test_models.py
    tests/campaign/test_cpm_tracker.py
  </files>
  <action>
    1. Install new dependencies: `uv add fastapi uvicorn tenacity structlog httpx`

    2. Create `src/negotiation/campaign/__init__.py` with alphabetically sorted __all__ exports (per ruff RUF022).

    3. Create `src/negotiation/campaign/models.py`:
       - `CampaignInfluencer(BaseModel, frozen=True)`: name (str), platform (Platform), engagement_rate (float | None = None)
       - `CampaignCPMRange(BaseModel, frozen=True)`: min_cpm (Decimal), max_cpm (Decimal) -- add field_validator to reject float input (follow PayRange pattern from domain/models.py)
       - `Campaign(BaseModel, frozen=True)`: campaign_id (str, Field description="ClickUp task ID"), client_name (str), budget (Decimal with float rejection), target_deliverables (str), influencers (list[CampaignInfluencer]), cpm_range (CampaignCPMRange), platform (Platform), timeline (str), created_at (str ISO 8601)
       - Import Platform from negotiation.domain.types

    4. Create `src/negotiation/campaign/cpm_tracker.py`:
       - `CPMFlexibility` dataclass: target_cpm (Decimal), max_allowed_cpm (Decimal), reason (str)
       - `CampaignCPMTracker` class:
         - __init__(campaign_id: str, target_min_cpm: Decimal, target_max_cpm: Decimal, total_influencers: int)
         - record_agreement(cpm: Decimal, engagement_rate: float | None = None) -> None
         - running_average_cpm property -> Decimal | None
         - get_flexibility(influencer_engagement_rate: float | None) -> CPMFlexibility
       - Per LOCKED DECISION: Flexibility must consider engagement quality, NOT just campaign averaging alone. High engagement (>5%) gets up to 15% CPM premium. Moderate engagement (>3%) gets 8% premium. Hard cap: never exceed 120% of target max CPM.
       - Include _build_reason helper that explains the flexibility decision (for audit trail and team transparency)

    5. Create `config/campaign_fields.yaml`:
       ```yaml
       # Maps ClickUp custom field names to Campaign model fields
       # Update these to match your ClickUp form's custom field names
       field_mapping:
         "Client Name": "client_name"
         "Budget": "budget"
         "Target Deliverables": "target_deliverables"
         "Influencer List": "influencers_raw"
         "CPM Min": "cpm_min"
         "CPM Max": "cpm_max"
         "Platform": "platform"
         "Timeline": "timeline"

       # How the influencer list is formatted in ClickUp
       influencer_list_format: "comma_separated"  # or "newline_separated"
       ```

    6. Create `src/negotiation/audit/__init__.py` with alphabetically sorted __all__ exports.

    7. Create `src/negotiation/audit/models.py`:
       - `EventType(StrEnum)` with values: email_sent, email_received, state_transition, escalation, agreement, takeover, campaign_start, campaign_influencer_skip, error
       - `AuditEntry(BaseModel)`: event_type (EventType), campaign_id (str | None), influencer_name (str | None), thread_id (str | None), direction (str | None), email_body (str | None), negotiation_state (str | None), rates_used (str | None), intent_classification (str | None), metadata (dict[str, str] | None)
       Per LOCKED DECISION: Full context per entry including all these fields.

    8. Create tests:
       - `tests/campaign/test_models.py`: Test Campaign model validation (float rejection on budget/CPM, Platform enum validation, frozen immutability), CampaignInfluencer with optional engagement_rate, CampaignCPMRange with Decimal precision.
       - `tests/campaign/test_cpm_tracker.py`: Test CPMFlexibility with no agreements yet (returns campaign max), with running average below target (more flexibility), with running average above target (less flexibility), with high engagement rate (>5% gets 15% premium), with moderate engagement (>3% gets 8% premium), hard cap at 120% of target max, all influencers agreed (returns target max). Test that engagement quality actually changes the max_allowed_cpm.

    Verify all tests pass with `uv run pytest tests/campaign/ -v` and quality gates pass with `uv run ruff check src/negotiation/campaign/ src/negotiation/audit/` and `uv run mypy src/negotiation/campaign/ src/negotiation/audit/`.
  </action>
  <verify>
    `uv run pytest tests/campaign/ tests/audit/ -v` passes all tests.
    `uv run ruff check src/negotiation/campaign/ src/negotiation/audit/` reports no issues.
    `uv run mypy src/negotiation/campaign/ src/negotiation/audit/` reports no errors.
    `uv run python -c "from negotiation.campaign.models import Campaign, CampaignInfluencer, CampaignCPMRange; from negotiation.campaign.cpm_tracker import CampaignCPMTracker, CPMFlexibility; from negotiation.audit.models import EventType, AuditEntry; print('All imports OK')"` succeeds.
  </verify>
  <done>
    Campaign models validate ClickUp-sourced fields with Decimal precision and float rejection. CPM tracker calculates flexibility with engagement-quality weighting (high engagement gets 15% premium, moderate gets 8%, hard cap at 120% of target max). Audit models define all event types and entry fields per locked decisions. Config YAML maps ClickUp custom fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SQLite audit store and resilience retry decorator</name>
  <files>
    src/negotiation/audit/store.py
    src/negotiation/resilience/__init__.py
    src/negotiation/resilience/retry.py
    tests/audit/test_store.py
  </files>
  <action>
    1. Create `src/negotiation/audit/store.py`:
       - `init_audit_db(db_path: Path) -> sqlite3.Connection`: Create connection, enable WAL mode (`PRAGMA journal_mode=WAL`), enable foreign keys, create `audit_log` table with: id (INTEGER PRIMARY KEY AUTOINCREMENT), timestamp (TEXT NOT NULL DEFAULT ISO8601 now), event_type (TEXT NOT NULL), campaign_id (TEXT), influencer_name (TEXT), thread_id (TEXT), direction (TEXT), email_body (TEXT), negotiation_state (TEXT), rates_used (TEXT), intent_classification (TEXT), metadata (TEXT). Create indexes on influencer_name, campaign_id, timestamp. Commit and return connection.
       - `insert_audit_entry(conn: sqlite3.Connection, entry: AuditEntry) -> int`: Insert entry fields using parameterized queries (? placeholders, NEVER string concatenation per research anti-patterns). Serialize metadata dict to JSON string if present. Return lastrowid.
       - `query_audit_trail(conn: sqlite3.Connection, influencer_name: str | None = None, campaign_id: str | None = None, from_date: str | None = None, to_date: str | None = None, event_type: str | None = None, limit: int = 50) -> list[dict[str, Any]]`: Build WHERE clause dynamically with parameterized queries. Return results as list of dicts using `sqlite3.Row` row factory. Order by timestamp DESC.
       - `close_audit_db(conn: sqlite3.Connection) -> None`: Close the connection.

    2. Create `src/negotiation/resilience/__init__.py` with alphabetically sorted __all__ exports.

    3. Create `src/negotiation/resilience/retry.py`:
       - Import tenacity: retry, stop_after_attempt, wait_exponential_jitter, RetryCallState
       - Import structlog for logging
       - `notify_slack_on_final_failure(retry_state: RetryCallState) -> None`: Log the failure with structlog. Post error to Slack #errors channel using SlackNotifier if available (import conditionally to avoid circular dependency -- use a module-level _notifier variable set via configure_error_notifier function).
       - `configure_error_notifier(notifier: Any) -> None`: Set the module-level notifier for error reporting.
       - `resilient_api_call(api_name: str)` -> decorator factory: Returns tenacity retry decorator with stop_after_attempt(3), wait_exponential_jitter(initial=1, max=30, jitter=5), before_sleep logs warning with api name and attempt number, retry_error_callback=notify_slack_on_final_failure, reraise=True.
       Per LOCKED DECISION: Retry 3 times with backoff, then post error to Slack #errors channel.

    4. Create `tests/audit/test_store.py`:
       - Use tmp_path fixture for SQLite database
       - Test init_audit_db creates database file and WAL mode is enabled
       - Test insert_audit_entry returns row ID and stores all fields correctly
       - Test query_audit_trail filters by influencer_name
       - Test query_audit_trail filters by campaign_id
       - Test query_audit_trail filters by date range (from_date, to_date)
       - Test query_audit_trail filters by event_type
       - Test query_audit_trail with limit parameter
       - Test query_audit_trail returns results in timestamp DESC order
       - Test metadata field round-trips through JSON serialization
       - Test parameterized queries prevent SQL injection (insert name with SQL characters)

    Verify all tests pass with `uv run pytest tests/audit/ -v` and quality gates pass.
  </action>
  <verify>
    `uv run pytest tests/audit/test_store.py -v` passes all tests.
    `uv run ruff check src/negotiation/audit/ src/negotiation/resilience/` reports no issues.
    `uv run mypy src/negotiation/audit/ src/negotiation/resilience/` reports no errors.
    `uv run python -c "from negotiation.audit.store import init_audit_db, insert_audit_entry, query_audit_trail; from negotiation.resilience.retry import resilient_api_call, configure_error_notifier; print('All imports OK')"` succeeds.
  </verify>
  <done>
    SQLite audit store initializes with WAL mode, creates indexed audit_log table, inserts entries with parameterized queries, and queries with flexible filtering by influencer/campaign/date/event_type. Resilience retry decorator wraps API calls with 3 attempts, exponential backoff with jitter (1s initial, 30s max, 5s jitter), and posts to Slack #errors on final failure. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest tests/campaign/ tests/audit/ -v` -- all tests pass
- `uv run ruff check src/negotiation/campaign/ src/negotiation/audit/ src/negotiation/resilience/` -- clean
- `uv run mypy src/negotiation/campaign/ src/negotiation/audit/ src/negotiation/resilience/` -- no errors
- Campaign model rejects float budget/CPM fields (follows PayRange pattern)
- CPM tracker flexibility differs based on engagement rate (high vs moderate vs none)
- SQLite WAL mode confirmed via `PRAGMA journal_mode` query in test
- Audit store uses parameterized queries (no string concatenation)
</verification>

<success_criteria>
- Campaign, CampaignInfluencer, CampaignCPMRange models importable and validate correctly
- CampaignCPMTracker produces different flexibility for high-engagement vs low-engagement influencers
- SQLite audit store initializes, inserts, and queries with proper indexing
- Resilience retry decorator configurable per API name with Slack notification on exhaustion
- Config YAML maps ClickUp field names to campaign model fields
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-campaign-ingestion-and-operational-readiness/05-01-SUMMARY.md`
</output>
