---
phase: 05-campaign-ingestion-and-operational-readiness
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/negotiation/campaign/webhook.py
  - src/negotiation/campaign/ingestion.py
  - src/negotiation/campaign/__init__.py
  - tests/campaign/test_webhook.py
  - tests/campaign/test_ingestion.py
autonomous: true
requirements:
  - DATA-01

must_haves:
  truths:
    - "ClickUp webhook POST is verified via HMAC-SHA256 signature before processing"
    - "Campaign data is parsed from ClickUp task custom fields into Campaign model"
    - "For each influencer in a campaign, the agent looks them up in Google Sheet and starts a negotiation"
    - "Missing influencers (not in Google Sheet) are skipped with a Slack alert asking team to add them"
    - "Team receives a Slack notification when a campaign ingestion starts"
  artifacts:
    - path: "src/negotiation/campaign/webhook.py"
      provides: "FastAPI endpoint for ClickUp webhook with HMAC verification"
      min_lines: 60
    - path: "src/negotiation/campaign/ingestion.py"
      provides: "Campaign processing: parse task -> lookup influencers -> start negotiations"
      min_lines: 80
    - path: "tests/campaign/test_webhook.py"
      provides: "Webhook signature verification and endpoint tests"
      min_lines: 50
    - path: "tests/campaign/test_ingestion.py"
      provides: "Campaign ingestion pipeline tests with mocked external services"
      min_lines: 80
  key_links:
    - from: "src/negotiation/campaign/webhook.py"
      to: "src/negotiation/campaign/ingestion.py"
      via: "webhook handler calls process_campaign_task"
      pattern: "process_campaign_task|ingest_campaign"
    - from: "src/negotiation/campaign/ingestion.py"
      to: "src/negotiation/sheets/client.py"
      via: "looks up influencer in Google Sheet"
      pattern: "SheetsClient|get_influencer|find_influencer"
    - from: "src/negotiation/campaign/ingestion.py"
      to: "src/negotiation/slack/client.py"
      via: "posts Slack notification on campaign start and missing influencers"
      pattern: "SlackNotifier|post_message|chat_postMessage"

user_setup:
  - service: clickup
    why: "Webhook receives campaign form submissions"
    env_vars:
      - name: CLICKUP_API_TOKEN
        source: "ClickUp Settings -> Apps -> API Token"
      - name: CLICKUP_WEBHOOK_SECRET
        source: "Returned when webhook is created via ClickUp API"
---

<objective>
Create the ClickUp webhook receiver and campaign ingestion pipeline that automatically starts negotiations when a campaign form is submitted.

Purpose: This is the entry point for new campaigns. When a team member submits a ClickUp form, the webhook fires, the agent parses campaign data, looks up each influencer in the Google Sheet, and starts negotiations for all found influencers while alerting on any missing ones.

Output: FastAPI webhook endpoint with HMAC signature verification, campaign ingestion pipeline that bridges ClickUp data to the existing negotiation system.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-campaign-ingestion-and-operational-readiness/05-RESEARCH.md
@.planning/phases/05-campaign-ingestion-and-operational-readiness/05-01-SUMMARY.md

# Campaign models from Plan 01
@src/negotiation/campaign/models.py
@src/negotiation/campaign/cpm_tracker.py

# Google Sheets client for influencer lookup
@src/negotiation/sheets/client.py
@src/negotiation/sheets/models.py

# Slack client for notifications
@src/negotiation/slack/client.py
@src/negotiation/slack/blocks.py

# Config pattern
@config/campaign_fields.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: ClickUp webhook endpoint with HMAC signature verification</name>
  <files>
    src/negotiation/campaign/webhook.py
    tests/campaign/test_webhook.py
  </files>
  <action>
    1. Create `src/negotiation/campaign/webhook.py`:
       - Create FastAPI app instance: `app = FastAPI(title="Negotiation Agent Webhooks")`
       - Read `CLICKUP_WEBHOOK_SECRET` from environment variable (os.environ)
       - `verify_signature(body: bytes, signature: str, secret: str) -> bool`: Compute HMAC-SHA256 using `hmac.new(secret.encode(), body, hashlib.sha256).hexdigest()` and compare with `hmac.compare_digest()`. CRITICAL per research pitfall 4: Always verify against raw body bytes BEFORE parsing as JSON.
       - `@app.post("/webhooks/clickup")` endpoint:
         - Accept `request: Request` (NOT a Pydantic model -- must get raw body first for signature verification)
         - Read raw body with `await request.body()`
         - Get signature from `X-Signature` header
         - Verify signature; raise HTTPException(401) on failure
         - Parse body as JSON AFTER signature verification
         - Check `event` field -- only process "taskCreated"
         - Extract `task_id` from payload
         - Call `process_campaign_task(task_id)` from ingestion module (import at function level or via dependency injection to avoid circular imports)
         - Return `{"status": "ok"}` immediately
         - Per LOCKED DECISION: One-way data flow only (ClickUp -> agent), no status sync back
       - Add health check endpoint: `@app.get("/health")` returning `{"status": "healthy"}`

    2. Create `tests/campaign/test_webhook.py`:
       - Use `fastapi.testclient.TestClient` for endpoint testing
       - Test valid signature passes verification
       - Test invalid signature returns 401
       - Test missing signature header returns 401
       - Test non-taskCreated events return 200 but do not trigger ingestion (use mock to verify process_campaign_task not called)
       - Test taskCreated event triggers process_campaign_task with correct task_id (mock the ingestion call)
       - Test health check endpoint returns 200
       - Use `hmac.new` to generate valid test signatures in test fixtures

    Verify: `uv run pytest tests/campaign/test_webhook.py -v` passes, `uv run ruff check src/negotiation/campaign/webhook.py`, `uv run mypy src/negotiation/campaign/webhook.py`.
  </action>
  <verify>
    `uv run pytest tests/campaign/test_webhook.py -v` passes all tests.
    `uv run ruff check src/negotiation/campaign/webhook.py` reports no issues.
    `uv run mypy src/negotiation/campaign/webhook.py` reports no errors.
  </verify>
  <done>
    FastAPI webhook endpoint receives ClickUp POST requests, verifies HMAC-SHA256 signature against raw body bytes (not parsed JSON), processes only taskCreated events, and delegates to ingestion pipeline. Invalid signatures get 401. Health check available at /health.
  </done>
</task>

<task type="auto">
  <name>Task 2: Campaign ingestion pipeline bridging ClickUp data to negotiation system</name>
  <files>
    src/negotiation/campaign/ingestion.py
    src/negotiation/campaign/__init__.py
    tests/campaign/test_ingestion.py
  </files>
  <action>
    1. Create `src/negotiation/campaign/ingestion.py`:
       - `load_field_mapping(config_path: Path | None = None) -> dict[str, str]`: Load campaign_fields.yaml using yaml.safe_load (follow existing pattern from escalation_triggers.yaml loading). Return field_mapping dict. Default path: `config/campaign_fields.yaml`.
       - `fetch_clickup_task(task_id: str, api_token: str) -> dict[str, Any]`: Use httpx.AsyncClient to GET `https://api.clickup.com/api/v2/task/{task_id}` with Authorization header. Per research pitfall 1: Always follow up webhook with GET to fetch full task including custom fields (webhook payload may NOT include custom field values). Apply resilient_api_call("clickup") retry decorator.
       - `parse_custom_fields(task_data: dict[str, Any], field_mapping: dict[str, str]) -> dict[str, Any]`: Extract custom field values from task_data["custom_fields"] list. For each field, match by name against field_mapping. Handle ClickUp type casting per research pitfall 3: numbers may be strings, dates as Unix milliseconds. Return dict mapping campaign model field names to values.
       - `parse_influencer_list(raw_value: str, list_format: str = "comma_separated") -> list[str]`: Split influencer names from text field. Support comma-separated and newline-separated formats. Strip whitespace. Filter empty strings.
       - `build_campaign(task_id: str, parsed_fields: dict[str, Any]) -> Campaign`: Construct Campaign model from parsed fields. Convert budget/CPM to Decimal. Build CampaignInfluencer list from parsed influencer names with platform from campaign. Set created_at to current ISO 8601 timestamp.
       - `async def ingest_campaign(task_id: str, api_token: str, sheets_client: Any, slack_notifier: Any, config_path: Path | None = None) -> dict[str, Any]`: Main orchestration function:
         a. Load field mapping
         b. Fetch full task from ClickUp API
         c. Parse custom fields
         d. Build Campaign model
         e. For each influencer in campaign.influencers:
            - Look up in Google Sheet via sheets_client.find_influencer_by_name()
            - If found: add to `found_influencers` list with their sheet data
            - If NOT found: add to `missing_influencers` list. Per LOCKED DECISION: skip and post Slack alert asking team to add them first
         f. Post Slack notification that campaign ingestion started (team name, number of influencers found/missing). Per LOCKED DECISION: auto-start, team gets Slack notification.
         g. For each missing influencer: post individual Slack alert with influencer name and campaign context
         h. Return dict with campaign model, found_influencers, missing_influencers for downstream use
       Note: This function does NOT start the actual negotiation loop -- that wiring happens in Plan 04 (app.py). This plan builds the ingestion pipeline up to the point of having campaign + influencer data ready.

    2. Update `src/negotiation/campaign/__init__.py` to export all new public symbols alphabetically.

    3. Create `tests/campaign/test_ingestion.py`:
       - Test load_field_mapping reads YAML correctly (use tmp_path for test config)
       - Test load_field_mapping with missing file returns empty or raises clear error
       - Test parse_custom_fields extracts values from ClickUp custom fields structure
       - Test parse_custom_fields handles missing fields gracefully (returns None)
       - Test parse_influencer_list with comma-separated names
       - Test parse_influencer_list with newline-separated names
       - Test parse_influencer_list strips whitespace and filters empty strings
       - Test build_campaign constructs valid Campaign model
       - Test ingest_campaign with all influencers found (mock sheets_client, slack_notifier, httpx)
       - Test ingest_campaign with some influencers missing (verify Slack alert called for each)
       - Test ingest_campaign with all influencers missing (verify all skipped, alerts sent)
       - Mock httpx.AsyncClient for fetch_clickup_task tests (mock the GET response with custom fields payload)

    Verify: `uv run pytest tests/campaign/ -v` passes all tests, quality gates pass.
  </action>
  <verify>
    `uv run pytest tests/campaign/ -v` passes all tests (including test_models.py, test_cpm_tracker.py from Plan 01, test_webhook.py from Task 1, and test_ingestion.py).
    `uv run ruff check src/negotiation/campaign/` reports no issues.
    `uv run mypy src/negotiation/campaign/` reports no errors.
    `uv run python -c "from negotiation.campaign import Campaign, ingest_campaign, CampaignCPMTracker; print('All exports OK')"` succeeds.
  </verify>
  <done>
    Campaign ingestion pipeline fetches full task from ClickUp API (not relying on webhook payload alone per pitfall 1), parses custom fields with type-aware casting, builds Campaign model, looks up each influencer in Google Sheet, skips missing influencers with Slack alerts (per locked decision), and posts campaign start notification. Configurable field mapping via YAML.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest tests/campaign/ -v` -- all tests pass
- `uv run ruff check src/negotiation/campaign/` -- clean
- `uv run mypy src/negotiation/campaign/` -- no errors
- Webhook verifies HMAC signature against raw body bytes (not parsed JSON)
- Ingestion follows up webhook with GET to ClickUp API for full task data
- Missing influencers trigger Slack alerts (not silent failures)
- Campaign start triggers Slack notification to team
- No status sync back to ClickUp (one-way flow per locked decision)
</verification>

<success_criteria>
- ClickUp webhook endpoint verifies signatures and delegates to ingestion
- Campaign ingestion fetches full task, parses custom fields, builds Campaign model
- Each influencer is looked up in Google Sheet -- found ones are ready for negotiation, missing ones trigger Slack alerts
- Team gets Slack notification on campaign start
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-campaign-ingestion-and-operational-readiness/05-02-SUMMARY.md`
</output>
