---
phase: 01-core-domain-and-pricing-engine
plan: 03
type: tdd
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/negotiation/state_machine/machine.py
  - src/negotiation/state_machine/transitions.py
  - src/negotiation/state_machine/__init__.py
  - tests/state_machine/__init__.py
  - tests/state_machine/test_machine.py
  - tests/state_machine/test_transitions.py
autonomous: true
requirements:
  - NEG-04
  - NEG-07

must_haves:
  truths:
    - "A negotiation can transition through all defined states: initial_offer -> awaiting_reply -> counter_received -> counter_sent -> awaiting_reply (and eventually to agreed, rejected, escalated, or stale)"
    - "Invalid transitions are rejected with InvalidTransitionError (e.g., AGREED -> COUNTER_SENT is impossible)"
    - "Terminal states (AGREED, REJECTED) reject all events"
    - "The escalated state can resume to counter_sent (after human review) or reject"
    - "Stale threads can be revived when a reply is received (STALE -> COUNTER_RECEIVED)"
    - "Every state transition is recorded in history for audit purposes"
  artifacts:
    - path: "src/negotiation/state_machine/transitions.py"
      provides: "Transition map defining all valid (state, event) -> state mappings"
      exports: ["TRANSITIONS", "NegotiationEvent"]
    - path: "src/negotiation/state_machine/machine.py"
      provides: "NegotiationStateMachine class with trigger, history, and valid_events"
      exports: ["NegotiationStateMachine"]
    - path: "tests/state_machine/test_machine.py"
      provides: "Parameterized tests for all valid and invalid transitions"
      min_lines: 80
    - path: "tests/state_machine/test_transitions.py"
      provides: "Transition map completeness tests"
      min_lines: 30
  key_links:
    - from: "src/negotiation/state_machine/transitions.py"
      to: "src/negotiation/domain/types.py"
      via: "import NegotiationState"
      pattern: "from negotiation\\.domain\\.types import NegotiationState"
    - from: "src/negotiation/state_machine/machine.py"
      to: "src/negotiation/state_machine/transitions.py"
      via: "import TRANSITIONS to validate state changes"
      pattern: "from negotiation\\.state_machine\\.transitions import"
    - from: "src/negotiation/state_machine/machine.py"
      to: "src/negotiation/domain/errors.py"
      via: "raises InvalidTransitionError on invalid transitions"
      pattern: "from negotiation\\.domain\\.errors import InvalidTransitionError"
    - from: "tests/state_machine/test_machine.py"
      to: "src/negotiation/state_machine/machine.py"
      via: "parameterized tests for all (state, event) pairs"
      pattern: "from negotiation\\.state_machine\\.machine import"
---

<objective>
Build the negotiation state machine using TDD: define all valid state transitions, implement the state machine class with transition validation, and prove correctness with exhaustive parameterized tests covering every (state, event) pair.

Purpose: The state machine governs the negotiation lifecycle. An invalid transition (e.g., sending a counter-offer after agreement) would cause the agent to send inappropriate emails. Every transition must be explicitly allowed or explicitly rejected. TDD ensures completeness because the tests enumerate ALL possible (state, event) pairs -- 8 states x ~8 events = 64 combinations, each tested.

Output: A battle-tested state machine module with 100% transition coverage. Every valid path works, every invalid path raises, and every transition is auditable through history.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-domain-and-pricing-engine/01-RESEARCH.md
@.planning/phases/01-core-domain-and-pricing-engine/01-01-SUMMARY.md
</context>

<feature>
  <name>Negotiation State Machine</name>
  <files>
    src/negotiation/state_machine/transitions.py
    src/negotiation/state_machine/machine.py
    src/negotiation/state_machine/__init__.py
    tests/state_machine/__init__.py
    tests/state_machine/test_transitions.py
    tests/state_machine/test_machine.py
  </files>
  <behavior>
    Valid transitions (from_state, event -> to_state):
    - (INITIAL_OFFER, send_offer) -> AWAITING_REPLY
    - (AWAITING_REPLY, receive_reply) -> COUNTER_RECEIVED
    - (AWAITING_REPLY, timeout) -> STALE
    - (COUNTER_RECEIVED, send_counter) -> COUNTER_SENT
    - (COUNTER_RECEIVED, accept) -> AGREED
    - (COUNTER_RECEIVED, reject) -> REJECTED
    - (COUNTER_RECEIVED, escalate) -> ESCALATED
    - (COUNTER_SENT, receive_reply) -> COUNTER_RECEIVED
    - (COUNTER_SENT, timeout) -> STALE
    - (ESCALATED, resume_counter) -> COUNTER_SENT
    - (ESCALATED, reject) -> REJECTED
    - (STALE, receive_reply) -> COUNTER_RECEIVED
    - (STALE, reject) -> REJECTED

    Terminal states (AGREED, REJECTED) reject ALL events.
    All other invalid (state, event) pairs raise InvalidTransitionError.

    Machine API:
    - NegotiationStateMachine(initial_state=INITIAL_OFFER)
    - .state -> current NegotiationState
    - .trigger(event: str) -> NegotiationState (new state, or raises)
    - .is_terminal -> bool (True for AGREED, REJECTED)
    - .get_valid_events() -> list[str] (events valid from current state)
    - .history -> list of (from_state, event, to_state) tuples

    Happy path walkthrough:
    sm = NegotiationStateMachine()
    sm.trigger("send_offer")     # -> AWAITING_REPLY
    sm.trigger("receive_reply")  # -> COUNTER_RECEIVED
    sm.trigger("send_counter")   # -> COUNTER_SENT
    sm.trigger("receive_reply")  # -> COUNTER_RECEIVED
    sm.trigger("accept")         # -> AGREED
    sm.trigger("send_offer")     # -> raises InvalidTransitionError (terminal)
    len(sm.history) == 5         # All 5 transitions recorded
  </behavior>
  <implementation>
    Follow TDD RED-GREEN-REFACTOR cycle:

    **RED phase -- Write failing tests first:**

    tests/state_machine/test_transitions.py:
    - Test TRANSITIONS dict has exactly 13 valid entries
    - Test all 8 NegotiationState values appear as source states in at least one transition (or are terminal)
    - Test AGREED and REJECTED do not appear as source states in any transition
    - Test every DeliverableType... (wrong enum) -- actually test that NegotiationEvent enum has the expected members: send_offer, receive_reply, timeout, send_counter, accept, reject, escalate, resume_counter

    tests/state_machine/test_machine.py:
    - Parameterized test for ALL 13 valid transitions: start at from_state, trigger event, assert new state equals expected to_state
    - Parameterized test for terminal states (AGREED, REJECTED) x ALL 8 events: each must raise InvalidTransitionError
    - Parameterized test for invalid non-terminal transitions: for each non-terminal state, test events that are NOT valid from that state (e.g., INITIAL_OFFER + "receive_reply" is invalid). Enumerate these explicitly.
    - Test happy path walkthrough: INITIAL_OFFER -> send_offer -> receive_reply -> send_counter -> receive_reply -> accept = AGREED
    - Test escalation path: ... -> COUNTER_RECEIVED -> escalate -> ESCALATED -> resume_counter -> COUNTER_SENT
    - Test stale revival: AWAITING_REPLY -> timeout -> STALE -> receive_reply -> COUNTER_RECEIVED
    - Test history recording: after N transitions, history has N entries with correct (from, event, to) tuples
    - Test get_valid_events returns correct events for INITIAL_OFFER (only ["send_offer"])
    - Test get_valid_events returns empty list for AGREED
    - Test is_terminal returns True for AGREED and REJECTED, False for all others
    - Test machine default initial state is INITIAL_OFFER
    - Test machine accepts custom initial state

    Run tests -- all MUST fail (RED).
    Commit: "test(01-03): add failing tests for negotiation state machine"

    **GREEN phase -- Implement to pass:**

    src/negotiation/state_machine/transitions.py:
    - Define NegotiationEvent(StrEnum) with members: SEND_OFFER = "send_offer", RECEIVE_REPLY = "receive_reply", TIMEOUT = "timeout", SEND_COUNTER = "send_counter", ACCEPT = "accept", REJECT = "reject", ESCALATE = "escalate", RESUME_COUNTER = "resume_counter"
    - Define TRANSITIONS: dict[tuple[NegotiationState, str], NegotiationState] with all 13 valid mappings (use string values for events in the keys, matching NegotiationEvent values)
    - Define TERMINAL_STATES: frozenset = {NegotiationState.AGREED, NegotiationState.REJECTED}

    src/negotiation/state_machine/machine.py:
    - NegotiationStateMachine class:
      - __init__(self, initial_state: NegotiationState = NegotiationState.INITIAL_OFFER)
      - _state: NegotiationState (private)
      - _history: list[tuple[NegotiationState, str, NegotiationState]] (private)
      - state property -> NegotiationState
      - is_terminal property -> bool (checks if state in TERMINAL_STATES)
      - history property -> list (returns copy of _history)
      - trigger(event: str) -> NegotiationState:
        - If is_terminal, raise InvalidTransitionError(self._state, event)
        - Look up (self._state, event) in TRANSITIONS
        - If not found, raise InvalidTransitionError(self._state, event)
        - Record (old_state, event, new_state) in _history
        - Update _state to new_state
        - Return new_state
      - get_valid_events() -> list[str]:
        - Return sorted list of events where (self._state, event) exists in TRANSITIONS
        - If terminal, return empty list

    Update state_machine/__init__.py to re-export NegotiationStateMachine, NegotiationEvent, TRANSITIONS, TERMINAL_STATES.

    Run tests -- all MUST pass (GREEN).
    Commit: "feat(01-03): implement negotiation state machine with transition validation"

    **REFACTOR phase (if needed):**
    - Ensure InvalidTransitionError messages are descriptive (include current state and attempted event)
    - Run ruff format and ruff check, fix any issues
    - Run mypy strict, fix any type errors
    - Run tests again -- all MUST pass
    - Commit only if changes made: "refactor(01-03): clean up state machine module"
  </implementation>
</feature>

<verification>
- `uv run pytest tests/state_machine/ -v --tb=short` -- all tests pass
- `uv run pytest tests/state_machine/ --cov=src/negotiation/state_machine --cov-report=term-missing` -- coverage >= 95%
- `uv run mypy src/negotiation/state_machine/` -- no type errors
- `uv run ruff check src/negotiation/state_machine/ tests/state_machine/` -- no lint errors
- `uv run pytest tests/ -v --tb=short` -- ALL tests across the project pass (domain + pricing + state_machine)
- `uv run python -c "from negotiation.state_machine import NegotiationStateMachine; sm = NegotiationStateMachine(); sm.trigger('send_offer'); sm.trigger('receive_reply'); sm.trigger('accept'); assert sm.state == 'agreed'; assert sm.is_terminal; print('State machine works')"` -- prints confirmation
</verification>

<success_criteria>
1. All 13 valid transitions produce the correct target state
2. All invalid transitions (including terminal state + any event) raise InvalidTransitionError
3. The happy path (offer -> reply -> counter -> reply -> accept) reaches AGREED state
4. The escalation path (counter_received -> escalate -> resume_counter) works correctly
5. Stale threads can be revived (stale -> receive_reply -> counter_received)
6. History records every transition as (from_state, event, to_state) tuple
7. get_valid_events returns correct events for each state
8. All state machine tests pass, mypy strict passes, ruff passes, coverage >= 95%
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-domain-and-pricing-engine/01-03-SUMMARY.md`
</output>
