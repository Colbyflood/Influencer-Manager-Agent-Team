---
phase: 01-core-domain-and-pricing-engine
plan: 02
type: tdd
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/negotiation/pricing/engine.py
  - src/negotiation/pricing/rate_cards.py
  - src/negotiation/pricing/boundaries.py
  - src/negotiation/pricing/__init__.py
  - tests/pricing/__init__.py
  - tests/pricing/test_engine.py
  - tests/pricing/test_rate_cards.py
  - tests/pricing/test_boundaries.py
autonomous: true
requirements:
  - NEG-02
  - NEG-03
  - NEG-07

must_haves:
  truths:
    - "Given an influencer with 50,000 average views, the initial offer is exactly $1,000.00 (50000/1000 * $20 CPM)"
    - "Given an influencer with 50,000 average views and a proposed rate of $1,750, the system returns should_escalate=True because implied CPM is $35 which exceeds the $30 ceiling"
    - "Given a proposed rate implying sub-$15 CPM, the system returns a suspiciously_low warning"
    - "The pricing engine handles all 8 deliverable types and returns correct rates for each"
    - "The pricing engine rejects 0 or negative average_views with a clear error"
    - "CPM floor ($20) and ceiling ($30) are configurable parameters, not hardcoded magic numbers"
  artifacts:
    - path: "src/negotiation/pricing/engine.py"
      provides: "CPM rate calculation functions"
      exports: ["calculate_rate", "calculate_initial_offer", "calculate_cpm_from_rate"]
    - path: "src/negotiation/pricing/rate_cards.py"
      provides: "Platform-specific rate card and pricing per deliverable"
      exports: ["calculate_deliverable_rate", "RateCard"]
    - path: "src/negotiation/pricing/boundaries.py"
      provides: "Rate boundary enforcement and escalation logic"
      exports: ["evaluate_proposed_rate", "BoundaryResult", "PricingResult"]
    - path: "tests/pricing/test_engine.py"
      provides: "CPM calculation tests with edge cases"
      min_lines: 60
    - path: "tests/pricing/test_boundaries.py"
      provides: "Boundary enforcement and escalation tests"
      min_lines: 50
  key_links:
    - from: "src/negotiation/pricing/engine.py"
      to: "src/negotiation/domain/types.py"
      via: "import DeliverableType"
      pattern: "from negotiation\\.domain"
    - from: "src/negotiation/pricing/boundaries.py"
      to: "src/negotiation/pricing/engine.py"
      via: "uses calculate_cpm_from_rate to evaluate proposals"
      pattern: "from negotiation\\.pricing\\.engine import"
    - from: "src/negotiation/pricing/rate_cards.py"
      to: "src/negotiation/domain/types.py"
      via: "import Platform, DeliverableType for rate card lookup"
      pattern: "from negotiation\\.domain\\.types import"
    - from: "tests/pricing/test_engine.py"
      to: "src/negotiation/pricing/engine.py"
      via: "import and test calculation functions"
      pattern: "from negotiation\\.pricing\\.engine import"
---

<objective>
Build the deterministic pricing engine using TDD: CPM-based rate calculation, platform-specific rate cards, and rate boundary enforcement with escalation triggers.

Purpose: The pricing engine is the core business logic that determines what rates to offer influencers and whether a proposed rate is acceptable, too high (escalate), or suspiciously low (warn). Every negotiation action depends on these calculations being exact. Using TDD ensures the math is proven correct before wiring to downstream systems.

Output: Three tested modules (engine.py, rate_cards.py, boundaries.py) with comprehensive tests covering normal cases, edge cases, and boundary conditions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-domain-and-pricing-engine/01-RESEARCH.md
@.planning/phases/01-core-domain-and-pricing-engine/01-01-SUMMARY.md
</context>

<feature>
  <name>CPM-Based Pricing Engine</name>
  <files>
    src/negotiation/pricing/engine.py
    src/negotiation/pricing/rate_cards.py
    src/negotiation/pricing/boundaries.py
    src/negotiation/pricing/__init__.py
    tests/pricing/__init__.py
    tests/pricing/test_engine.py
    tests/pricing/test_rate_cards.py
    tests/pricing/test_boundaries.py
  </files>
  <behavior>
    Core CPM calculation:
    - calculate_rate(average_views=50000, cpm=Decimal("20")) -> Decimal("1000.00")
    - calculate_rate(average_views=100, cpm=Decimal("20")) -> Decimal("2.00")
    - calculate_rate(average_views=10000000, cpm=Decimal("20")) -> Decimal("200000.00")
    - calculate_rate(average_views=0, cpm=Decimal("20")) -> raises PricingError
    - calculate_initial_offer(average_views=50000) -> Decimal("1000.00") (uses $20 CPM floor)
    - calculate_cpm_from_rate(rate=Decimal("1500"), average_views=50000) -> Decimal("30.00")

    Rate cards:
    - calculate_deliverable_rate(deliverable_type=INSTAGRAM_REEL, average_views=50000) -> rate at CPM floor
    - All 8 deliverable types produce valid rates
    - Mismatched platform/deliverable raises InvalidDeliverableError

    Boundary enforcement:
    - evaluate_proposed_rate(rate=$1500, views=50000) -> within_range (CPM=$30, at ceiling but not over)
    - evaluate_proposed_rate(rate=$1750, views=50000) -> exceeds_ceiling, should_escalate=True (CPM=$35)
    - evaluate_proposed_rate(rate=$500, views=50000) -> below_floor (CPM=$10, below $20 floor)
    - evaluate_proposed_rate(rate=$300, views=50000) -> suspiciously_low (CPM=$6, below $15 threshold)
    - evaluate_proposed_rate(rate=$1250, views=50000) -> within_range (CPM=$25)
  </behavior>
  <implementation>
    Follow TDD RED-GREEN-REFACTOR cycle for each module:

    **RED phase -- Write failing tests first:**

    tests/pricing/test_engine.py:
    - Parameterized tests for calculate_rate with multiple (views, cpm, expected_rate) tuples including edge cases: 100 views, 1000 views, 50000 views, 500000 views, 10000000 views
    - Test calculate_rate with 0 views raises PricingError
    - Test calculate_rate with negative views raises PricingError
    - Test calculate_initial_offer uses CPM floor ($20) by default
    - Test calculate_cpm_from_rate back-calculates correctly
    - Test calculate_cpm_from_rate with 0 views raises PricingError
    - Test all calculations use Decimal (not float) -- verify exact equality, never assertAlmostEqual

    tests/pricing/test_rate_cards.py:
    - Test calculate_deliverable_rate returns correct rate for each of the 8 deliverable types
    - Test rate card uses Decimal arithmetic throughout
    - Test rate card accepts configurable CPM floor/ceiling parameters (defaults to $20/$30)

    tests/pricing/test_boundaries.py:
    - Parameterized tests for evaluate_proposed_rate with cases covering: within_range, exceeds_ceiling, below_floor, suspiciously_low
    - Test should_escalate is True only when CPM exceeds ceiling
    - Test warning messages are present for exceeds_ceiling and suspiciously_low
    - Test warning is None for within_range and below_floor
    - Test configurable thresholds (custom floor, ceiling, low_rate_threshold)
    - Test edge case: rate exactly at ceiling ($30 CPM) is within_range (not escalated)
    - Test edge case: rate exactly at floor ($20 CPM) is within_range

    Run tests -- all MUST fail (RED).
    Commit: "test(01-02): add failing tests for pricing engine, rate cards, and boundaries"

    **GREEN phase -- Implement to pass:**

    src/negotiation/pricing/engine.py:
    - Module-level constants: TWO_PLACES = Decimal("0.01"), CPM_FLOOR = Decimal("20"), CPM_CEILING = Decimal("30")
    - calculate_rate(average_views: int, cpm: Decimal) -> Decimal: validates views > 0, computes (views / 1000) * cpm, quantizes to 2 decimal places with ROUND_HALF_UP
    - calculate_initial_offer(average_views: int, cpm_floor: Decimal = CPM_FLOOR) -> Decimal: calls calculate_rate with floor CPM
    - calculate_cpm_from_rate(rate: Decimal, average_views: int) -> Decimal: validates views > 0, back-calculates (rate / (views/1000)), quantizes

    src/negotiation/pricing/rate_cards.py:
    - Define a RateCard Pydantic model (frozen=True) with: deliverable_type, platform, cpm_floor (default $20), cpm_ceiling (default $30)
    - DEFAULT_RATE_CARDS: dict mapping each DeliverableType to its RateCard (for v1, all use $20-$30 range, but architecture supports per-type ranges)
    - calculate_deliverable_rate(deliverable_type: DeliverableType, average_views: int, cpm: Decimal | None = None) -> Decimal: looks up rate card, uses cpm_floor if cpm not provided, calls calculate_rate
    - get_rate_card(deliverable_type: DeliverableType) -> RateCard

    src/negotiation/pricing/boundaries.py:
    - BoundaryResult(StrEnum): WITHIN_RANGE, EXCEEDS_CEILING, BELOW_FLOOR, SUSPICIOUSLY_LOW
    - PricingResult(BaseModel, frozen=True): rate (Decimal), cpm (Decimal), boundary (BoundaryResult), should_escalate (bool), warning (str | None)
    - evaluate_proposed_rate(proposed_rate: Decimal, average_views: int, cpm_floor: Decimal = CPM_FLOOR, cpm_ceiling: Decimal = CPM_CEILING, low_rate_threshold: Decimal = Decimal("15")) -> PricingResult
      Logic: calculate implied CPM, compare against ceiling (exceeds -> escalate), low_rate_threshold (suspicious), floor (below but ok), else within_range

    Update pricing/__init__.py to re-export key functions and types.

    Run tests -- all MUST pass (GREEN).
    Commit: "feat(01-02): implement pricing engine, rate cards, and boundary enforcement"

    **REFACTOR phase (if needed):**
    - Check for any code duplication between engine.py and boundaries.py
    - Ensure all Decimal operations use quantize consistently
    - Run ruff format and ruff check, fix any issues
    - Run mypy strict, fix any type errors
    - Run tests again -- all MUST pass
    - Commit only if changes made: "refactor(01-02): clean up pricing module"
  </implementation>
</feature>

<verification>
- `uv run pytest tests/pricing/ -v --tb=short` -- all tests pass
- `uv run pytest tests/pricing/ --cov=src/negotiation/pricing --cov-report=term-missing` -- coverage >= 95%
- `uv run mypy src/negotiation/pricing/` -- no type errors
- `uv run ruff check src/negotiation/pricing/ tests/pricing/` -- no lint errors
- `uv run python -c "from negotiation.pricing import calculate_rate, evaluate_proposed_rate, BoundaryResult; from decimal import Decimal; r = evaluate_proposed_rate(Decimal('1750'), 50000); assert r.should_escalate == True; print('Boundary enforcement works')"` -- prints confirmation
</verification>

<success_criteria>
1. calculate_rate(50000, Decimal("20")) returns exactly Decimal("1000.00") (not 999.99 or 1000.0000001)
2. evaluate_proposed_rate correctly identifies rates above $30 CPM ceiling as should_escalate=True
3. evaluate_proposed_rate correctly warns on suspiciously low rates (below $15 CPM)
4. All 8 deliverable types produce valid rates via rate cards
5. CPM floor/ceiling are configurable parameters, not hardcoded throughout
6. Zero and negative views raise PricingError, not division by zero
7. All pricing tests pass, mypy strict passes, ruff passes, coverage >= 95%
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-domain-and-pricing-engine/01-02-SUMMARY.md`
</output>
