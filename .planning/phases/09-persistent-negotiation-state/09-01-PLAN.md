---
phase: 09-persistent-negotiation-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/negotiation/state/__init__.py
  - src/negotiation/state/schema.py
  - src/negotiation/state/store.py
  - src/negotiation/state/serializers.py
  - src/negotiation/state_machine/machine.py
  - src/negotiation/state_machine/__init__.py
  - src/negotiation/campaign/cpm_tracker.py
  - tests/state/test_store.py
  - tests/state/test_serializers.py
autonomous: true
requirements:
  - STATE-01
  - STATE-02

must_haves:
  truths:
    - "NegotiationStateStore can save a negotiation and load it back with identical state, context, campaign, and CPM tracker data"
    - "NegotiationStateMachine can be reconstructed from a saved state and history without replaying events"
    - "CampaignCPMTracker can be serialized to dict and reconstructed with all agreements intact"
    - "Decimal values survive a JSON round-trip without precision loss (no floats)"
    - "load_active() returns only non-terminal negotiations (filters out agreed/rejected)"
  artifacts:
    - path: "src/negotiation/state/store.py"
      provides: "NegotiationStateStore with save, load_active, init_table methods"
      exports: ["NegotiationStateStore"]
    - path: "src/negotiation/state/schema.py"
      provides: "init_negotiation_state_table DDL function"
      exports: ["init_negotiation_state_table"]
    - path: "src/negotiation/state/serializers.py"
      provides: "serialize/deserialize functions for context dict and CPM tracker"
      exports: ["serialize_context", "deserialize_context", "serialize_cpm_tracker", "deserialize_cpm_tracker"]
    - path: "src/negotiation/state_machine/machine.py"
      provides: "from_snapshot classmethod on NegotiationStateMachine"
      contains: "from_snapshot"
    - path: "src/negotiation/campaign/cpm_tracker.py"
      provides: "to_dict and from_dict methods on CampaignCPMTracker"
      contains: "to_dict"
  key_links:
    - from: "src/negotiation/state/store.py"
      to: "src/negotiation/state/schema.py"
      via: "init_negotiation_state_table called in store or by caller"
      pattern: "init_negotiation_state_table"
    - from: "src/negotiation/state/store.py"
      to: "sqlite3.Connection"
      via: "parameterized INSERT OR REPLACE and SELECT queries"
      pattern: "INSERT OR REPLACE INTO negotiation_state"
    - from: "src/negotiation/state/serializers.py"
      to: "src/negotiation/campaign/cpm_tracker.py"
      via: "CampaignCPMTracker.to_dict/from_dict for lossless serialization"
      pattern: "to_dict|from_dict"
---

<objective>
Create the SQLite-backed negotiation state persistence module with serialization helpers for all domain objects.

Purpose: Provide the data layer that saves/loads negotiation state to SQLite so Phase 9's crash-recovery guarantee (STATE-01, STATE-02) can be wired into the app. The store follows the existing audit trail pattern (same database, same WAL mode, same parameterized queries).

Output: `src/negotiation/state/` package with store, schema, and serializers; `from_snapshot()` classmethod on NegotiationStateMachine; `to_dict()`/`from_dict()` on CampaignCPMTracker; unit tests for all serialization round-trips.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-persistent-negotiation-state/09-RESEARCH.md

@src/negotiation/audit/store.py
@src/negotiation/state_machine/machine.py
@src/negotiation/state_machine/transitions.py
@src/negotiation/campaign/cpm_tracker.py
@src/negotiation/campaign/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state persistence module (schema, store, serializers) and domain object serialization methods</name>
  <files>
    src/negotiation/state/__init__.py
    src/negotiation/state/schema.py
    src/negotiation/state/store.py
    src/negotiation/state/serializers.py
    src/negotiation/state_machine/machine.py
    src/negotiation/state_machine/__init__.py
    src/negotiation/campaign/cpm_tracker.py
  </files>
  <action>
Create `src/negotiation/state/` package with three modules:

**schema.py** -- Table DDL following the existing `init_audit_db()` pattern in `src/negotiation/audit/store.py`:
- `init_negotiation_state_table(conn: sqlite3.Connection) -> None` function
- CREATE TABLE IF NOT EXISTS negotiation_state with columns:
  - thread_id TEXT PRIMARY KEY
  - state TEXT NOT NULL (NegotiationState enum .value)
  - round_count INTEGER NOT NULL DEFAULT 0
  - context_json TEXT NOT NULL
  - campaign_json TEXT NOT NULL
  - cpm_tracker_json TEXT NOT NULL
  - history_json TEXT NOT NULL DEFAULT '[]'
  - created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ', 'now'))
  - updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ', 'now'))
- CREATE INDEX IF NOT EXISTS idx_neg_state_state ON negotiation_state (state)
- Call conn.commit() after DDL

**store.py** -- NegotiationStateStore class mirroring the AuditLogger pattern:
- Constructor takes `sqlite3.Connection`
- `save(thread_id, state_machine, context, campaign, cpm_tracker_data, round_count)` method:
  - Uses INSERT OR REPLACE with COALESCE subquery to preserve original created_at
  - Serializes state_machine.state.value as TEXT, state_machine history as JSON array of [from.value, event, to.value] triples
  - campaign via campaign.model_dump_json()
  - cpm_tracker_data is already a dict (caller passes serialized form)
  - context via json.dumps
  - Calls conn.commit() after write (synchronous, not deferred)
  - Sets updated_at to current UTC time
- `load_active()` method:
  - SELECT * FROM negotiation_state WHERE state NOT IN (...terminal states...)
  - Uses TERMINAL_STATES from negotiation.state_machine.transitions
  - Returns list[dict[str, Any]] with row data
  - Sets row_factory = sqlite3.Row for dict conversion
- `delete(thread_id)` method for optional cleanup

**serializers.py** -- Standalone serialization functions:
- `serialize_context(context: dict[str, Any]) -> str`: JSON-encode context dict, converting any Decimal values to str to avoid TypeError
- `deserialize_context(json_str: str) -> dict[str, Any]`: json.loads (note: Decimal fields come back as strings, which is fine since the negotiation loop does `Decimal(str(context["next_cpm"]))`)
- `serialize_cpm_tracker(tracker: CampaignCPMTracker) -> dict[str, Any]`: Calls `tracker.to_dict()` (added below)
- `deserialize_cpm_tracker(data: dict[str, Any]) -> CampaignCPMTracker`: Calls `CampaignCPMTracker.from_dict(data)` (added below)

**__init__.py** -- Export NegotiationStateStore, init_negotiation_state_table, and all serializer functions.

**Modify `src/negotiation/state_machine/machine.py`:**
- Add `@classmethod from_snapshot(cls, state: NegotiationState, history: list[tuple[NegotiationState, str, NegotiationState]]) -> NegotiationStateMachine` classmethod
- Creates instance with `initial_state=state`
- Sets `instance._history = list(history)` (defensive copy)
- This makes the persistence contract explicit instead of external code accessing _history directly

**Update `src/negotiation/state_machine/__init__.py`:**
- No changes needed; NegotiationStateMachine is already re-exported

**Modify `src/negotiation/campaign/cpm_tracker.py`:**
- Add `to_dict(self) -> dict[str, Any]` method to CampaignCPMTracker:
  - Returns dict with campaign_id (str), target_min_cpm (str(Decimal)), target_max_cpm (str(Decimal)), total_influencers (int), agreements (list of {"cpm": str(Decimal), "engagement_rate": float|None})
  - Decimal values serialized as strings to avoid precision loss
- Add `@classmethod from_dict(cls, data: dict[str, Any]) -> CampaignCPMTracker` to CampaignCPMTracker:
  - Reconstructs tracker from dict
  - Converts str back to Decimal for cpm fields
  - Replays _agreements list from data["agreements"]

All modules use type hints, docstrings, and `from __future__ import annotations`.
  </action>
  <verify>
Run `python -c "from negotiation.state.store import NegotiationStateStore; from negotiation.state.schema import init_negotiation_state_table; from negotiation.state.serializers import serialize_context, deserialize_context, serialize_cpm_tracker, deserialize_cpm_tracker; print('imports ok')"` to verify clean imports.

Run `python -c "from negotiation.state_machine.machine import NegotiationStateMachine; sm = NegotiationStateMachine.from_snapshot(NegotiationStateMachine().state, []); print('from_snapshot ok')"` to verify the classmethod.

Run `python -c "from negotiation.campaign.cpm_tracker import CampaignCPMTracker; from decimal import Decimal; t = CampaignCPMTracker('c1', Decimal('20'), Decimal('30'), 5); d = t.to_dict(); t2 = CampaignCPMTracker.from_dict(d); print('to_dict/from_dict ok')"` to verify round-trip.

Run `ruff check src/negotiation/state/ src/negotiation/state_machine/machine.py src/negotiation/campaign/cpm_tracker.py` for lint.
Run `mypy src/negotiation/state/ src/negotiation/state_machine/machine.py src/negotiation/campaign/cpm_tracker.py` for type checking.
  </verify>
  <done>
- src/negotiation/state/ package exists with schema.py, store.py, serializers.py, __init__.py
- NegotiationStateStore has save(), load_active(), delete() methods with parameterized queries
- init_negotiation_state_table() creates the table with all columns and index
- NegotiationStateMachine.from_snapshot() classmethod exists and constructs from saved state + history
- CampaignCPMTracker.to_dict()/from_dict() methods exist and handle Decimal precision correctly
- All imports resolve, lint passes, types check
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for state store, serializers, and domain object round-trips</name>
  <files>
    tests/state/__init__.py
    tests/state/test_store.py
    tests/state/test_serializers.py
  </files>
  <action>
Create `tests/state/` package with two test modules:

**test_store.py** -- Tests for NegotiationStateStore using an in-memory SQLite database:
- `test_save_and_load_active_round_trip`: Create a state machine (trigger "send_offer" to get AWAITING_REPLY), build a context dict with a Decimal next_cpm, create a Campaign model, create a CampaignCPMTracker with one recorded agreement, serialize and save via store.save(). Then call store.load_active() and verify all fields match: state == "awaiting_reply", round_count matches, context_json deserializes with correct values, campaign_json round-trips via Campaign.model_validate_json(), cpm_tracker_json deserializes with correct agreements.
- `test_save_overwrites_existing_preserves_created_at`: Save twice with different states. Verify updated_at changes but created_at stays the same (COALESCE logic).
- `test_load_active_excludes_terminal_states`: Save three negotiations -- one AWAITING_REPLY, one AGREED, one REJECTED. Call load_active(). Verify only the AWAITING_REPLY row is returned.
- `test_delete_removes_row`: Save a negotiation, delete it by thread_id, verify load_active returns empty.
- `test_init_table_is_idempotent`: Call init_negotiation_state_table twice on same connection, verify no error.

**test_serializers.py** -- Tests for serialization round-trips:
- `test_serialize_context_handles_decimal`: Create context dict with Decimal("25.50") for next_cpm. Serialize, deserialize, verify next_cpm is string "25.50" (Decimal precision preserved as str).
- `test_serialize_context_handles_plain_types`: Context with str, int, list[str] fields round-trips correctly.
- `test_cpm_tracker_round_trip`: Create CampaignCPMTracker with two recorded agreements (Decimal CPMs + engagement rates). Serialize via to_dict(), deserialize via from_dict(). Verify campaign_id, target_min/max_cpm, total_influencers, and _agreements list match exactly.
- `test_cpm_tracker_empty_agreements`: Round-trip with no recorded agreements.
- `test_state_machine_from_snapshot_round_trip`: Create NegotiationStateMachine, trigger several events to build history. Extract state and history. Reconstruct via from_snapshot(). Verify state matches, history matches, and get_valid_events() returns correct events for current state.

Use pytest fixtures for in-memory SQLite connection setup. Follow existing test patterns in the project.
  </action>
  <verify>
Run `pytest tests/state/ -v` -- all tests pass.
Run `pytest tests/ -x --timeout=30` -- all existing tests still pass (no regressions).
  </verify>
  <done>
- All unit tests pass for NegotiationStateStore save/load/delete operations
- Terminal state filtering verified (agreed/rejected excluded from load_active)
- Decimal precision preserved across JSON serialization round-trips
- NegotiationStateMachine.from_snapshot() reconstructs correctly from saved data
- CampaignCPMTracker.to_dict()/from_dict() round-trips with agreements intact
- No regressions in existing test suite
  </done>
</task>

</tasks>

<verification>
1. `python -c "from negotiation.state import NegotiationStateStore, init_negotiation_state_table"` succeeds
2. `pytest tests/state/ -v` -- all tests pass
3. `pytest tests/ -x --timeout=30` -- no regressions
4. `ruff check src/negotiation/state/ src/negotiation/state_machine/ src/negotiation/campaign/cpm_tracker.py` -- clean
5. `mypy src/negotiation/state/ src/negotiation/state_machine/ src/negotiation/campaign/cpm_tracker.py` -- clean
</verification>

<success_criteria>
- NegotiationStateStore exists with save(), load_active(), delete() methods
- init_negotiation_state_table() creates the SQLite schema
- NegotiationStateMachine.from_snapshot() reconstructs from persisted state + history
- CampaignCPMTracker.to_dict()/from_dict() handle Decimal losslessly
- All serializers handle Decimal -> str -> Decimal round-trip without precision loss
- All tests pass including full save-load round-trip verification
</success_criteria>

<output>
After completion, create `.planning/phases/09-persistent-negotiation-state/09-01-SUMMARY.md`
</output>
