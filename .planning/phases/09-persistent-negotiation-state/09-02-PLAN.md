---
phase: 09-persistent-negotiation-state
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/negotiation/app.py
  - tests/test_app.py
autonomous: true
requirements:
  - STATE-01
  - STATE-02

must_haves:
  truths:
    - "Every state transition in start_negotiations_for_campaign is persisted to SQLite before the function moves to the next influencer"
    - "Every state transition in process_inbound_email is persisted to SQLite before the email reply is sent"
    - "After a simulated restart, non-terminal negotiations are loaded from the database and present in negotiation_states dict"
    - "Terminal negotiations (agreed, rejected) are NOT loaded on startup recovery"
    - "The in-memory negotiation_states dict and SQLite table stay consistent after every operation"
  artifacts:
    - path: "src/negotiation/app.py"
      provides: "State store initialization, startup recovery, save-on-every-transition wiring"
      contains: "state_store.save"
    - path: "tests/test_app.py"
      provides: "Integration tests for state persistence and startup recovery"
      contains: "test_state_persistence"
  key_links:
    - from: "src/negotiation/app.py"
      to: "src/negotiation/state/store.py"
      via: "NegotiationStateStore.save() called after every negotiation_states dict mutation"
      pattern: "state_store\\.save"
    - from: "src/negotiation/app.py"
      to: "src/negotiation/state/schema.py"
      via: "init_negotiation_state_table() called in initialize_services after init_audit_db"
      pattern: "init_negotiation_state_table"
    - from: "src/negotiation/app.py"
      to: "src/negotiation/state/store.py"
      via: "state_store.load_active() called in initialize_services for startup recovery"
      pattern: "load_active"
---

<objective>
Wire the negotiation state store into the application so every state transition is persisted to SQLite and non-terminal negotiations are recovered on startup.

Purpose: Complete the STATE-01 (write-before-response) and STATE-02 (startup recovery) guarantees by integrating the state persistence module from Plan 01 into the two write sites in app.py and the initialization flow. After this plan, killing the process at any point loses zero negotiation state.

Output: Modified `src/negotiation/app.py` with state store wiring at initialization, both write sites, and startup recovery; integration tests proving the crash-recovery guarantee.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-persistent-negotiation-state/09-RESEARCH.md
@.planning/phases/09-persistent-negotiation-state/09-01-SUMMARY.md

@src/negotiation/app.py
@src/negotiation/state/store.py
@src/negotiation/state/schema.py
@src/negotiation/state/serializers.py
@src/negotiation/state_machine/machine.py
@src/negotiation/campaign/cpm_tracker.py
@src/negotiation/campaign/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire state store into initialize_services and both write sites in app.py</name>
  <files>
    src/negotiation/app.py
  </files>
  <action>
Modify `src/negotiation/app.py` to integrate the NegotiationStateStore at three points:

**1. Initialization (in `initialize_services()`, after step (a) audit DB init):**

Add imports at top of file:
```python
from negotiation.state.schema import init_negotiation_state_table
from negotiation.state.store import NegotiationStateStore
from negotiation.state.serializers import serialize_context, serialize_cpm_tracker, deserialize_context, deserialize_cpm_tracker
```

After `audit_conn = init_audit_db(audit_db_path)` and `services["audit_conn"] = audit_conn`, add:
```python
# Initialize negotiation state table on same audit DB connection
init_negotiation_state_table(audit_conn)
state_store = NegotiationStateStore(audit_conn)
services["state_store"] = state_store
```

**2. Startup Recovery (in `initialize_services()`, after step (j) creates `negotiation_states` dict):**

After `services["negotiation_states"] = negotiation_states`, add recovery logic:
- Import `NegotiationStateMachine` (already imported in start_negotiations_for_campaign; move to top-level import or use the existing lazy import)
- Import `Campaign` from `negotiation.campaign.models`
- Call `state_store.load_active()` to get all non-terminal rows
- For each row, reconstruct:
  - `NegotiationStateMachine.from_snapshot(NegotiationState(row["state"]), history_tuples)` where history_tuples are deserialized from history_json
  - `json.loads(row["context_json"])` for context (use `deserialize_context`)
  - `Campaign.model_validate_json(row["campaign_json"])` for campaign
  - `deserialize_cpm_tracker(json.loads(row["cpm_tracker_json"]))` for cpm_tracker
- Populate `negotiation_states[thread_id]` with reconstructed state machine, context, round_count, campaign, cpm_tracker
- Log: `logger.info("Negotiation state recovery complete", recovered=len(active_rows))`

**3. Write Site 1: `start_negotiations_for_campaign()` (after line 488 where negotiation_states[thread_id] is set):**

After `negotiation_states[thread_id] = { ... }`, add:
```python
# Persist to SQLite (STATE-01: write before moving to next influencer)
state_store = services.get("state_store")
if state_store is not None:
    state_store.save(
        thread_id=thread_id,
        state_machine=state_machine,
        context=context,
        campaign=campaign,
        cpm_tracker_data=serialize_cpm_tracker(cpm_tracker),
        round_count=0,
    )
```

Note: `serialize_cpm_tracker` calls `cpm_tracker.to_dict()` internally (from Plan 01).

**4. Write Site 2: `process_inbound_email()` (after the negotiation loop result, BEFORE sending reply):**

After `result = process_fn(...)` on line 698 and the dispatcher handling on line 708, but BEFORE the `if result["action"] == "send"` block on line 711, add a state save:

```python
# Persist state after negotiation loop (STATE-01: write before response)
state_store = services.get("state_store")
if state_store is not None:
    state_store.save(
        thread_id=inbound.thread_id,
        state_machine=state_machine,
        context=context,
        campaign=thread_state["campaign"],
        cpm_tracker_data=serialize_cpm_tracker(thread_state["cpm_tracker"]),
        round_count=thread_state["round_count"],
    )
```

After `thread_state["round_count"] += 1` on line 717 (inside the "send" action block), add a second save to persist the incremented round_count:

```python
    # Persist updated round_count after send (STATE-01)
    if state_store is not None:
        state_store.save(
            thread_id=inbound.thread_id,
            state_machine=state_machine,
            context=context,
            campaign=thread_state["campaign"],
            cpm_tracker_data=serialize_cpm_tracker(thread_state["cpm_tracker"]),
            round_count=thread_state["round_count"],
        )
```

This ensures: (1) state is saved before email send, (2) round_count is saved after successful send. If the process crashes between send and second save, the round_count is off by one but the state machine is correct.

Keep all existing logic intact. The state_store.save() calls are additive -- they don't replace the in-memory dict writes.
  </action>
  <verify>
Run `ruff check src/negotiation/app.py` -- clean.
Run `mypy src/negotiation/app.py` -- clean (or only pre-existing issues).
Run `python -c "from negotiation.app import initialize_services"` -- imports resolve.
  </verify>
  <done>
- init_negotiation_state_table() called in initialize_services() after audit DB init
- NegotiationStateStore created and stored in services["state_store"]
- Startup recovery loads all non-terminal negotiations from SQLite into negotiation_states dict
- start_negotiations_for_campaign() saves state to SQLite after each negotiation creation
- process_inbound_email() saves state to SQLite before sending reply AND after round_count increment
- All state saves use synchronous conn.commit() before any email/response is sent
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for state persistence wiring and startup recovery</name>
  <files>
    tests/test_app.py
  </files>
  <action>
Add integration tests to `tests/test_app.py` (or a new `tests/test_state_persistence.py` if test_app.py is already large) verifying the STATE-01 and STATE-02 guarantees:

**test_state_persistence_on_negotiation_start:**
- Create a minimal Settings object (following existing test patterns from Phase 8)
- Call initialize_services(settings) to get services dict
- Verify services["state_store"] is a NegotiationStateStore instance
- Verify the negotiation_state table exists (SELECT name FROM sqlite_master WHERE type='table')
- Manually create a NegotiationStateMachine, trigger "send_offer", build a context dict, create a Campaign, create a CampaignCPMTracker
- Call state_store.save() with these objects
- Verify state_store.load_active() returns 1 row with matching thread_id and state

**test_startup_recovery_loads_non_terminal:**
- Create an in-memory services dict with a state_store
- Save 3 negotiations: one AWAITING_REPLY, one AGREED (terminal), one COUNTER_RECEIVED
- Create a NEW services dict simulating a "restart" -- call initialize_services() again with same DB path (or reuse the connection)
- Verify the new services["negotiation_states"] contains exactly 2 entries (the non-terminal ones)
- Verify the state machines have correct states
- Verify the context dicts, campaigns, and CPM trackers round-tripped correctly

**test_startup_recovery_empty_database:**
- Call initialize_services() on a fresh database
- Verify services["negotiation_states"] is empty dict
- Verify no errors logged

**test_process_inbound_email_persists_state:**
- Set up services with state_store, a mock gmail_client, a mock anthropic_client
- Pre-populate negotiation_states with a thread in AWAITING_REPLY state
- Simulate process_inbound_email() (or directly verify that after the negotiation loop modifies state, state_store.load_active() reflects the new state)
- This may require mocking the gmail_client.get_message and process_fn to avoid external calls

Use in-memory SQLite (`:memory:`) for test isolation. Use existing test patterns: construct Settings explicitly, mock external clients.
  </action>
  <verify>
Run `pytest tests/test_app.py -v -k "state_persistence or startup_recovery"` -- new tests pass.
Run `pytest tests/ -x --timeout=60` -- all tests pass, no regressions.
  </verify>
  <done>
- Integration test verifies state_store is initialized in services dict
- Integration test verifies startup recovery loads non-terminal negotiations and skips terminal ones
- Integration test verifies state machine, context, campaign, and CPM tracker survive round-trip through SQLite
- Integration test verifies empty database recovery works without errors
- All existing tests still pass with no regressions
  </done>
</task>

</tasks>

<verification>
1. `grep -n "state_store.save" src/negotiation/app.py` shows 3+ save call sites (start_negotiations, pre-send, post-send)
2. `grep -n "load_active" src/negotiation/app.py` shows recovery in initialize_services
3. `grep -n "init_negotiation_state_table" src/negotiation/app.py` shows table creation on startup
4. `pytest tests/ -x --timeout=60` -- all tests pass
5. `ruff check src/negotiation/app.py` -- clean
</verification>

<success_criteria>
- Every negotiation state mutation in app.py is followed by a state_store.save() call
- Startup recovery in initialize_services() loads non-terminal negotiations from SQLite
- The in-memory dict and SQLite table are always consistent after every operation
- Integration tests prove: save round-trip, recovery after simulated restart, terminal state filtering
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/09-persistent-negotiation-state/09-02-SUMMARY.md`
</output>
