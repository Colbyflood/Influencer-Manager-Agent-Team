---
phase: 03-llm-negotiation-pipeline
plan: 03
type: tdd
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/negotiation/llm/composer.py
  - src/negotiation/llm/validation.py
  - tests/llm/test_composer.py
  - tests/llm/test_validation.py
autonomous: true
requirements:
  - NEG-06

must_haves:
  truths:
    - "The agent composes counter-offer emails with calculated rates, clear deliverable terms, and appropriate negotiation tone informed by the knowledge base"
    - "Composed emails are validated by a deterministic gate before sending -- no LLM validates LLM output"
    - "Validation catches mismatched monetary values, wrong deliverables, hallucinated commitments, and off-brand language"
    - "On validation failure, the email is blocked and an EscalationPayload is produced with the draft and failure reasons"
    - "Email composition uses Sonnet model and knowledge base content injected into system prompt"
  artifacts:
    - path: "src/negotiation/llm/composer.py"
      provides: "compose_counter_email function using Claude message creation"
      exports: ["compose_counter_email"]
      min_lines: 30
    - path: "src/negotiation/llm/validation.py"
      provides: "validate_composed_email deterministic validation gate"
      exports: ["validate_composed_email"]
      min_lines: 50
    - path: "tests/llm/test_composer.py"
      provides: "Tests for email composition with mocked API"
      min_lines: 40
    - path: "tests/llm/test_validation.py"
      provides: "Comprehensive tests for all validation checks (deterministic, no mocks needed)"
      min_lines: 80
  key_links:
    - from: "src/negotiation/llm/composer.py"
      to: "src/negotiation/llm/prompts.py"
      via: "imports EMAIL_COMPOSITION_SYSTEM_PROMPT, EMAIL_COMPOSITION_USER_PROMPT"
      pattern: "from negotiation.llm.prompts import"
    - from: "src/negotiation/llm/composer.py"
      to: "anthropic.Anthropic"
      via: "client.messages.create() with system prompt including KB content"
      pattern: "client\\.messages\\.create"
    - from: "src/negotiation/llm/validation.py"
      to: "src/negotiation/llm/models.py"
      via: "imports ValidationFailure, ValidationResult"
      pattern: "from negotiation.llm.models import"
---

<objective>
Build the email composition module that generates counter-offer emails using the knowledge base, and the deterministic validation gate that catches monetary errors, hallucinated commitments, and off-brand language before any email is sent.

Purpose: This is the "response" half of the LLM pipeline. The composer generates contextually appropriate negotiation emails; the validation gate ensures no incorrect or unauthorized email ever reaches an influencer.
Output: Tested `compose_counter_email` and `validate_composed_email` functions ready for use in the negotiation loop.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-llm-negotiation-pipeline/03-RESEARCH.md
@.planning/phases/03-llm-negotiation-pipeline/03-01-SUMMARY.md
@src/negotiation/llm/models.py
@src/negotiation/llm/prompts.py
@src/negotiation/llm/client.py
</context>

<feature>
  <name>Email Composition and Validation Gate</name>
  <files>src/negotiation/llm/composer.py, src/negotiation/llm/validation.py, tests/llm/test_composer.py, tests/llm/test_validation.py</files>
  <behavior>
    ## Email Composition
    compose_counter_email(influencer_name, their_rate, our_rate, deliverables_summary, platform, negotiation_stage, knowledge_base_content, negotiation_history, client, model?) -> ComposedEmail

    Cases:
    - Standard counter-offer -> returns ComposedEmail with email_body, model_used, token counts
    - System prompt includes knowledge base content injected via cache_control for prompt caching
    - User prompt includes all negotiation parameters formatted from template

    ## Validation Gate (deterministic, no LLM)
    validate_composed_email(email_body, expected_rate, expected_deliverables, influencer_name, forbidden_phrases?) -> ValidationResult

    Cases:
    - Clean email with correct rate and deliverables -> passed=True, no failures
    - Email with wrong dollar amount ($1,200 instead of $1,250) -> passed=False, monetary_value failure
    - Email with correct rate and extra unrelated dollar amount -> passed=False, monetary_value failure
    - Email mentioning "exclusivity" -> passed=False, hallucinated_commitment failure
    - Email mentioning "usage rights" -> passed=False, hallucinated_commitment failure
    - Email promising "future deals" -> passed=False, hallucinated_commitment failure
    - Email with "guarantee" -> passed=False, hallucinated_commitment failure
    - Email missing expected deliverable mention -> severity="warning" (not blocking)
    - Email with forbidden phrase -> passed=False, off_brand_language failure
    - Email shorter than 50 chars -> passed=False, too_short failure
    - Email with only warnings (no errors) -> passed=True (warnings don't block)
    - Multiple failures -> all collected in failures list
  </behavior>
  <implementation>
    1. compose_counter_email function in composer.py:
       - Accepts: influencer_name, their_rate (str), our_rate (str), deliverables_summary (str), platform (str), negotiation_stage (str), knowledge_base_content (str), negotiation_history (str), client (Anthropic), model (str, default=COMPOSE_MODEL)
       - Builds system prompt: EMAIL_COMPOSITION_SYSTEM_PROMPT.format(knowledge_base_content=knowledge_base_content)
       - Uses cache_control={"type": "ephemeral"} on system content block for prompt caching (90% cost savings on repeated KB content)
       - Builds user message: EMAIL_COMPOSITION_USER_PROMPT.format(influencer_name=..., platform=..., negotiation_stage=..., their_rate=..., our_rate=..., deliverables_summary=..., negotiation_history=...)
       - Calls client.messages.create(model=model, max_tokens=2048, system=[{"type": "text", "text": system_text, "cache_control": {"type": "ephemeral"}}], messages=[...])
       - Extracts response.content[0].text as email_body
       - Extracts response.usage.input_tokens and response.usage.output_tokens
       - Returns ComposedEmail(email_body=..., model_used=model, input_tokens=..., output_tokens=...)

    2. validate_composed_email function in validation.py:
       - Accepts: email_body (str), expected_rate (Decimal), expected_deliverables (list[str]), influencer_name (str), forbidden_phrases (list[str] | None, default=None)
       - Entirely deterministic -- NO LLM calls. Uses regex and string matching only.
       - Check 1 - Monetary values: regex findall for dollar amounts (r"\$[\d,]+(?:\.\d{2})?"), compare each to expected_rate. Normalize both (strip commas). Any mismatch = error.
       - Check 2 - Deliverable accuracy: for each expected deliverable, check if full name or short name (last segment after underscore, e.g., "reel" from "instagram_reel") appears in email (case-insensitive). Missing = warning (not error).
       - Check 3 - Hallucinated commitments: regex patterns for "exclusive/exclusivity", "usage rights/rights extension", "future deal/campaign/partnership", "guarantee". Any match = error.
       - Check 4 - Off-brand language: check if any forbidden_phrases appear in email (case-insensitive). Any match = error.
       - Check 5 - Basic sanity: email body stripped length < 50 chars = error ("too_short").
       - Collect all failures. passed = True only if zero error-severity failures (warnings allowed).
       - Return ValidationResult(passed=..., failures=..., email_body=...)

    3. Testing (test_composer.py):
       - Mock Anthropic client, mock messages.create return value with content[0].text and usage attributes
       - Test compose_counter_email returns ComposedEmail with correct fields
       - Test system prompt includes knowledge_base_content
       - Test user prompt includes all parameters
       - Test model parameter defaults to COMPOSE_MODEL
       - Test cache_control is set on system content

    4. Testing (test_validation.py -- no mocks needed, purely deterministic):
       - Test clean email passes validation
       - Test wrong monetary value fails with monetary_value check
       - Test multiple dollar amounts where one is wrong
       - Test hallucinated commitment patterns (exclusivity, usage rights, future deals, guarantee)
       - Test missing deliverable is warning not error
       - Test forbidden phrases
       - Test too-short email
       - Test email with only warnings passes (warnings don't block)
       - Test multiple simultaneous failures collected
       - Test expected rate with comma formatting ($1,250.00) matches correctly
  </implementation>
</feature>

<verification>
1. `uv run pytest tests/llm/test_composer.py tests/llm/test_validation.py -v` -- all tests pass (RED then GREEN)
2. `uv run ruff check src/negotiation/llm/composer.py src/negotiation/llm/validation.py` -- no lint errors
3. `uv run mypy src/negotiation/llm/composer.py src/negotiation/llm/validation.py` -- strict mode passes
</verification>

<success_criteria>
- compose_counter_email returns ComposedEmail with email body, token usage, and model used
- validate_composed_email catches: monetary mismatches, hallucinated commitments, missing deliverables (warning), forbidden phrases, too-short emails
- Validation gate is 100% deterministic -- no LLM calls anywhere in validation.py
- Per user decision: on validation failure, email is blocked (passed=False) -- the loop (Plan 04) routes to escalation
- All tests pass with mocked composer and deterministic validation
- mypy strict clean, ruff clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-llm-negotiation-pipeline/03-03-SUMMARY.md`
</output>
