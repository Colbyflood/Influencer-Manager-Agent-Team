---
phase: 12-monitoring-observability-and-live-verification
plan: 03
type: execute
wave: 2
depends_on:
  - 12-01
files_modified:
  - src/negotiation/state/schema.py
  - src/negotiation/state/watch_store.py
  - src/negotiation/config.py
  - src/negotiation/app.py
  - tests/state/test_watch_store.py
autonomous: true
requirements:
  - CONFIG-03

must_haves:
  truths:
    - "Gmail watch expiration timestamp is persisted to SQLite after every setup_watch() call"
    - "On process restart, the agent reads persisted expiration and renews immediately if expired"
    - "The renewal loop sleeps until (expiration - safety_margin), not for a fixed 6-day interval"
    - "If no persisted expiration exists (first run), the agent performs an immediate watch setup and persists the result"
  artifacts:
    - path: "src/negotiation/state/watch_store.py"
      provides: "GmailWatchStore class for persisting and loading watch expiration"
      exports: ["GmailWatchStore"]
    - path: "src/negotiation/state/schema.py"
      provides: "gmail_watch_state table DDL"
      contains: "gmail_watch_state"
    - path: "src/negotiation/app.py"
      provides: "Updated renew_gmail_watch_periodically using persisted expiration"
      contains: "watch_store"
    - path: "tests/state/test_watch_store.py"
      provides: "Unit tests for GmailWatchStore save/load and renewal logic"
      contains: "GmailWatchStore"
  key_links:
    - from: "src/negotiation/app.py"
      to: "src/negotiation/state/watch_store.py"
      via: "GmailWatchStore used in lifespan and renewal loop"
      pattern: "watch_store\\.save|watch_store\\.load"
    - from: "src/negotiation/state/watch_store.py"
      to: "src/negotiation/state/schema.py"
      via: "Schema creates gmail_watch_state table"
      pattern: "gmail_watch_state"
    - from: "src/negotiation/app.py (lifespan)"
      to: "src/negotiation/state/watch_store.py"
      via: "Persist expiration after setup_watch in lifespan"
      pattern: "watch_store\\.save.*expiration"
---

<objective>
Replace the fixed 6-day Gmail watch renewal timer with expiration-aware renewal based on a persisted timestamp, so process restarts do not cause missed emails.

Purpose: The current renew_gmail_watch_periodically sleeps for 6 days from process start. If the process restarts at day 5, it sleeps another 6 days, missing the 7-day expiry window. By persisting the actual expiration from Gmail's API response and computing sleep from (expiration - now - safety_margin), restarts are handled correctly.

Output: GmailWatchStore with SQLite persistence, updated renewal loop, and unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-monitoring-observability-and-live-verification/12-RESEARCH.md
@.planning/phases/12-monitoring-observability-and-live-verification/12-01-SUMMARY.md
@src/negotiation/app.py
@src/negotiation/state/schema.py
@src/negotiation/state/store.py
@src/negotiation/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GmailWatchStore and update schema, config, and renewal logic</name>
  <files>
    src/negotiation/state/schema.py
    src/negotiation/state/watch_store.py
    src/negotiation/config.py
    src/negotiation/app.py
  </files>
  <action>
    1. Update `src/negotiation/state/schema.py`:
       - Add a new function `init_gmail_watch_state_table(conn: sqlite3.Connection) -> None` that creates:
         ```sql
         CREATE TABLE IF NOT EXISTS gmail_watch_state (
             id INTEGER PRIMARY KEY CHECK (id = 1),
             expiration_ms INTEGER NOT NULL,
             history_id TEXT NOT NULL,
             updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ', 'now'))
         );
         ```
       - The `CHECK (id = 1)` enforces a singleton row pattern.

    2. Create `src/negotiation/state/watch_store.py`:
       - Define `GmailWatchStore` class:
         ```python
         class GmailWatchStore:
             def __init__(self, conn: sqlite3.Connection):
                 self._conn = conn

             def save(self, expiration_ms: int, history_id: str) -> None:
                 """Persist Gmail watch expiration and history ID (upsert singleton row)."""
                 now = datetime.now(tz=UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
                 self._conn.execute(
                     "INSERT OR REPLACE INTO gmail_watch_state (id, expiration_ms, history_id, updated_at) VALUES (1, ?, ?, ?)",
                     (expiration_ms, history_id, now),
                 )
                 self._conn.commit()

             def load(self) -> tuple[int, str] | None:
                 """Load persisted expiration_ms and history_id. Returns None if no record."""
                 cursor = self._conn.execute("SELECT expiration_ms, history_id FROM gmail_watch_state WHERE id = 1")
                 row = cursor.fetchone()
                 return (row[0], row[1]) if row else None
         ```

    3. Add one new field to `Settings` in `src/negotiation/config.py`:
       ```python
       gmail_watch_safety_margin_seconds: int = 3600  # Renew 1 hour before actual expiry
       ```

    4. Update `src/negotiation/app.py` -- `initialize_services()`:
       - After `init_negotiation_state_table(audit_conn)`, call `init_gmail_watch_state_table(audit_conn)` (import from `negotiation.state.schema`)
       - Create `watch_store = GmailWatchStore(audit_conn)` (import from `negotiation.state.watch_store`)
       - Add `services["watch_store"] = watch_store`

    5. Update `src/negotiation/app.py` -- `lifespan()`:
       - After `setup_watch()` succeeds, persist the expiration:
         ```python
         watch_store = services.get("watch_store")
         if watch_store is not None:
             expiration_ms = int(watch_result.get("expiration", 0))
             history_id_str = str(watch_result.get("historyId", ""))
             watch_store.save(expiration_ms, history_id_str)
             logger.info("Gmail watch expiration persisted", expiration_ms=expiration_ms)
         ```

    6. Replace `renew_gmail_watch_periodically()` in `src/negotiation/app.py` with expiration-aware version:
       ```python
       async def renew_gmail_watch_periodically(services: dict[str, Any]) -> None:
           """Renew Gmail watch based on persisted expiration timestamp.

           Sleeps until (expiration - safety_margin), then renews and persists
           the new expiration. Survives process restarts by reading persisted
           expiration on each loop iteration.
           """
           gmail_client = services.get("gmail_client")
           topic = services.get("gmail_pubsub_topic", "")
           watch_store = services.get("watch_store")
           settings = services.get("_settings")
           safety_margin = getattr(settings, "gmail_watch_safety_margin_seconds", 3600)

           if not gmail_client or not topic:
               return

           while True:
               # Read persisted expiration
               stored = watch_store.load() if watch_store else None
               if stored is not None:
                   expiration_ms, _ = stored
                   now_ms = int(time.time() * 1000)
                   sleep_seconds = max(0, (expiration_ms - now_ms) / 1000 - safety_margin)
               else:
                   sleep_seconds = 0  # No stored expiration -- renew immediately

               if sleep_seconds > 0:
                   logger.info("Gmail watch renewal sleeping", sleep_seconds=int(sleep_seconds))
                   await asyncio.sleep(sleep_seconds)

               try:
                   result = await asyncio.to_thread(gmail_client.setup_watch, topic)
                   new_expiration_ms = int(result.get("expiration", 0))
                   new_history_id = str(result.get("historyId", ""))

                   # Update in-memory history ID
                   async with services["history_lock"]:
                       if new_history_id:
                           services["history_id"] = new_history_id

                   # Persist new expiration
                   if watch_store is not None:
                       watch_store.save(new_expiration_ms, new_history_id)

                   logger.info("Gmail watch renewed", expiration_ms=new_expiration_ms, history_id=new_history_id)
               except Exception:
                   logger.exception("Failed to renew Gmail watch")
                   # On failure, retry in 5 minutes
                   await asyncio.sleep(300)
       ```
       - Add `import time` at the top of app.py if not already present.
  </action>
  <verify>
    - `python -c "from negotiation.state.watch_store import GmailWatchStore; print('OK')"` succeeds
    - `python -c "from negotiation.state.schema import init_gmail_watch_state_table; print('OK')"` succeeds
    - `python -c "from negotiation.config import Settings; s = Settings(); print(s.gmail_watch_safety_margin_seconds)"` prints 3600
    - `ruff check src/negotiation/state/watch_store.py src/negotiation/app.py` no lint errors
  </verify>
  <done>
    GmailWatchStore persists expiration to SQLite. Renewal loop computes sleep from actual expiry instead of fixed 6-day interval. Expiration persisted after every setup_watch call (both startup and renewal).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for GmailWatchStore and renewal logic</name>
  <files>
    tests/state/test_watch_store.py
  </files>
  <action>
    1. Create `tests/state/test_watch_store.py`:

       - **Fixture:** `watch_store` -- create an in-memory SQLite connection, call `init_gmail_watch_state_table(conn)`, return `GmailWatchStore(conn)`.

       - `test_save_and_load()`:
         - Save `expiration_ms=1700000000000, history_id="abc123"`
         - Load and assert `(1700000000000, "abc123")`

       - `test_load_returns_none_when_empty()`:
         - On fresh store, `load()` returns `None`

       - `test_save_overwrites_singleton()`:
         - Save twice with different values
         - Load returns the second value (not the first)
         - Verify only one row exists: `conn.execute("SELECT COUNT(*) FROM gmail_watch_state").fetchone()[0] == 1`

       - `test_save_updates_updated_at()`:
         - Save, read `updated_at` from raw SQL
         - Sleep briefly (or mock datetime), save again
         - Assert `updated_at` changed

       Run `pytest tests/state/test_watch_store.py -v` to verify all pass.
       Run `pytest tests/ -v` to verify no regressions in full suite.
  </action>
  <verify>
    - `pytest tests/state/test_watch_store.py -v` all tests pass
    - `pytest tests/ -v` full suite passes
    - `ruff check tests/state/test_watch_store.py` no lint errors
  </verify>
  <done>
    GmailWatchStore has complete unit test coverage: save/load, empty state, singleton enforcement, and timestamp updates. Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
1. GmailWatchStore save/load cycle works correctly with in-memory SQLite
2. Singleton row pattern enforced (only one row in gmail_watch_state)
3. `renew_gmail_watch_periodically` reads persisted expiration (not fixed 6-day interval)
4. On first run (no stored expiration), renewal happens immediately
5. After restart, persisted expiration determines next renewal time
6. `pytest tests/ -v` -- all tests pass
7. `ruff check src/ tests/` -- no lint errors
</verification>

<success_criteria>
- gmail_watch_state table created on startup alongside negotiation_state table
- GmailWatchStore.save() persists expiration_ms and history_id
- GmailWatchStore.load() returns persisted data or None
- Renewal loop computes sleep from (persisted_expiration - now - safety_margin)
- Expiration persisted after both startup watch setup and periodic renewal
- Safety margin configurable via gmail_watch_safety_margin_seconds setting (default 3600)
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-monitoring-observability-and-live-verification/12-03-SUMMARY.md`
</output>
