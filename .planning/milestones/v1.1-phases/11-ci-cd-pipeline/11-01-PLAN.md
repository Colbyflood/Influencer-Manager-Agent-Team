---
phase: 11-ci-cd-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [.github/workflows/ci.yml]
autonomous: false
requirements: [DEPLOY-03]

must_haves:
  truths:
    - "Pushing a commit to any branch triggers a GitHub Actions workflow"
    - "The workflow runs ruff lint, mypy typecheck, and pytest as three parallel jobs"
    - "A pull request shows CI status checks and cannot merge if any check fails"
    - "CI tests run in isolation without touching real databases or external services"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "CI workflow with lint, typecheck, and test jobs"
      contains: "ruff check"
    - path: ".github/workflows/ci.yml"
      provides: "mypy typecheck job"
      contains: "mypy src/"
    - path: ".github/workflows/ci.yml"
      provides: "pytest job"
      contains: "uv run pytest"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "pyproject.toml"
      via: "uv sync --locked --dev installs all dev dependencies configured in pyproject.toml"
      pattern: "uv sync --locked --dev"
    - from: ".github/workflows/ci.yml"
      to: ".python-version"
      via: "astral-sh/setup-uv reads Python version automatically"
      pattern: "astral-sh/setup-uv"
    - from: ".github/workflows/ci.yml"
      to: "uv.lock"
      via: "Cache invalidation keyed on lockfile hash"
      pattern: "cache-dependency-glob.*uv.lock"
---

<objective>
Create a GitHub Actions CI workflow that runs ruff lint, mypy typecheck, and pytest on every push and pull request, then configure branch protection to enforce these checks before merge.

Purpose: Catch regressions (lint violations, type errors, test failures) automatically before code reaches main. This is the final gate before monitoring/observability in Phase 12.
Output: `.github/workflows/ci.yml` with three parallel jobs (lint, typecheck, test) and branch protection on main requiring all three to pass.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-ci-cd-pipeline/11-RESEARCH.md
@pyproject.toml
@.python-version
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions CI workflow with three parallel jobs</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Create `.github/workflows/` directory and `.github/workflows/ci.yml` with the following structure:

**Triggers:** `on: push` (all branches, no branch filter) and `on: pull_request` (all branches). This ensures every push to any branch and every PR update triggers CI, satisfying the "any branch" success criterion.

**Concurrency control:** Add concurrency group `${{ github.workflow }}-${{ github.ref }}` with `cancel-in-progress: true` to avoid wasted runner minutes on rapid pushes.

**Three parallel jobs (no inter-job dependencies):**

1. **lint** job (`name: lint`, `runs-on: ubuntu-latest`):
   - `actions/checkout@v6`
   - `astral-sh/setup-uv@v7` with `enable-cache: true` and `cache-dependency-glob: "uv.lock"`
   - `uv sync --locked --dev`
   - `uv run ruff check --output-format=github .` (lint with inline PR annotations)
   - `uv run ruff format --check .` (format verification, no modifications)

2. **typecheck** job (`name: typecheck`, `runs-on: ubuntu-latest`):
   - `actions/checkout@v6`
   - `astral-sh/setup-uv@v7` with `enable-cache: true` and `cache-dependency-glob: "uv.lock"`
   - `uv sync --locked --dev`
   - `uv run mypy src/`

3. **test** job (`name: test`, `runs-on: ubuntu-latest`):
   - `actions/checkout@v6`
   - `astral-sh/setup-uv@v7` with `enable-cache: true` and `cache-dependency-glob: "uv.lock"`
   - `uv sync --locked --dev`
   - `uv run pytest` (no `--cov` flag to keep CI fast; coverage is a Phase 12 concern)

**Do NOT:**
- Hardcode a Python version in the workflow. `astral-sh/setup-uv@v7` reads `.python-version` automatically.
- Use `pip install` or `actions/setup-python`. The project uses `uv` exclusively.
- Use `uv sync` without `--locked`. The `--locked` flag ensures deterministic installs and catches stale lockfiles.
- Add branch protection via CLI in this task (requires the workflow to have run at least once first).

Use the exact YAML from the research Code Examples section as the base, but remove the `--cov=src/negotiation` flag from pytest (keep it simple, coverage tracking is Phase 12).
  </action>
  <verify>
Verify the file exists and has valid YAML syntax:
```bash
cat .github/workflows/ci.yml
python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))"
```
Verify the file contains the three job names (lint, typecheck, test), the trigger configuration (push + pull_request), and uses astral-sh/setup-uv@v7.
  </verify>
  <done>`.github/workflows/ci.yml` exists with three parallel jobs (lint, typecheck, test), triggers on push (all branches) and pull_request, uses `astral-sh/setup-uv@v7` with caching, and runs `ruff check`, `ruff format --check`, `mypy src/`, and `pytest`.</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Configure branch protection to require CI status checks</name>
  <action>
After the workflow file is pushed to main (or merged via PR), the CI workflow will run for the first time. Once it has run at least once, configure branch protection:

1. Push the workflow file to GitHub (commit and push, or merge a PR containing it)
2. Wait for the first CI run to complete (takes ~2-3 minutes)
3. Go to GitHub repository Settings > Branches > Add branch protection rule
4. Branch name pattern: `main`
5. Enable "Require status checks to pass before merging"
6. Search for and select these three required checks: `lint`, `typecheck`, `test`
7. Optionally enable "Require branches to be up to date before merging"
8. Save the protection rule

**Why this is a human-action checkpoint:** Branch protection rules require repository admin access through the GitHub UI or API. The `gh` CLI can set this via `gh api`, but it requires admin permissions that may not be configured. The GitHub Settings UI is the most reliable path.

**Alternative (if you prefer CLI):** The executor can attempt:
```bash
gh api repos/{owner}/{repo}/branches/main/protection \
  --method PUT \
  --field required_status_checks='{"strict":false,"contexts":["lint","typecheck","test"]}' \
  --field enforce_admins=false \
  --field required_pull_request_reviews=null \
  --field restrictions=null
```
If auth allows it, this works. If not, use the UI.
  </action>
  <verify>
1. Create a test branch, push a commit, open a PR against main
2. Verify that the CI workflow triggers and all three checks (lint, typecheck, test) appear on the PR
3. Verify the merge button is blocked until all checks pass (or shows "required checks" indicator)
  </verify>
  <done>Branch protection on `main` requires lint, typecheck, and test status checks to pass. PRs show the three CI checks and cannot merge until all pass.</done>
</task>

</tasks>

<verification>
1. `.github/workflows/ci.yml` exists with valid YAML syntax
2. Workflow triggers on both `push` (all branches) and `pull_request`
3. Three parallel jobs: `lint`, `typecheck`, `test`
4. Each job uses `astral-sh/setup-uv@v7` with `enable-cache: true`
5. Lint job runs `ruff check --output-format=github .` and `ruff format --check .`
6. Typecheck job runs `mypy src/`
7. Test job runs `pytest`
8. Branch protection on `main` requires all three checks to pass
9. No hardcoded Python version (reads from `.python-version`)
10. Uses `uv sync --locked --dev` (deterministic, catches stale lockfiles)
</verification>

<success_criteria>
- Pushing a commit to any branch triggers the CI workflow with all three jobs
- A PR against main shows lint, typecheck, and test as required status checks
- CI runs complete without touching external services (tests use mocks and in-memory SQLite)
- The merge button is blocked if any CI job fails
</success_criteria>

<output>
After completion, create `.planning/phases/11-ci-cd-pipeline/11-01-SUMMARY.md`
</output>
