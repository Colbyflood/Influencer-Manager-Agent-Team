---
phase: 01-core-domain-and-pricing-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - .python-version
  - src/negotiation/__init__.py
  - src/negotiation/domain/__init__.py
  - src/negotiation/domain/types.py
  - src/negotiation/domain/models.py
  - src/negotiation/domain/errors.py
  - src/negotiation/pricing/__init__.py
  - src/negotiation/state_machine/__init__.py
  - tests/__init__.py
  - tests/conftest.py
  - tests/domain/__init__.py
  - tests/domain/test_types.py
  - tests/domain/test_models.py
autonomous: true
requirements:
  - NEG-03

must_haves:
  truths:
    - "Platform enum has exactly three members: instagram, tiktok, youtube"
    - "DeliverableType enum has exactly 8 members covering all platform-specific deliverable types"
    - "NegotiationState enum has exactly 8 members matching the requirement states"
    - "PayRange model rejects float inputs for monetary fields and requires positive average_views"
    - "Deliverable model validates that deliverable type is valid for the given platform"
    - "All tests pass with pytest and type checking passes with mypy"
  artifacts:
    - path: "pyproject.toml"
      provides: "Project configuration with dependencies and tool settings"
      contains: "pydantic"
    - path: "src/negotiation/domain/types.py"
      provides: "Platform, DeliverableType, NegotiationState enums"
      exports: ["Platform", "DeliverableType", "NegotiationState"]
    - path: "src/negotiation/domain/models.py"
      provides: "PayRange, Deliverable, NegotiationContext Pydantic models"
      exports: ["PayRange", "Deliverable", "NegotiationContext"]
    - path: "src/negotiation/domain/errors.py"
      provides: "Domain-specific exception classes"
      exports: ["InvalidTransitionError", "InvalidDeliverableError", "PricingError"]
    - path: "tests/domain/test_types.py"
      provides: "Enum validation tests"
      min_lines: 30
    - path: "tests/domain/test_models.py"
      provides: "Pydantic model validation tests"
      min_lines: 50
  key_links:
    - from: "src/negotiation/domain/models.py"
      to: "src/negotiation/domain/types.py"
      via: "import Platform, DeliverableType, NegotiationState"
      pattern: "from negotiation\\.domain\\.types import"
    - from: "tests/domain/test_types.py"
      to: "src/negotiation/domain/types.py"
      via: "import and test all enum members"
      pattern: "from negotiation\\.domain\\.types import"
    - from: "tests/domain/test_models.py"
      to: "src/negotiation/domain/models.py"
      via: "import and test model validation"
      pattern: "from negotiation\\.domain\\.models import"
---

<objective>
Set up the Python project and implement all domain types, enums, and Pydantic models that the pricing engine and state machine depend on.

Purpose: Every downstream module (pricing engine, state machine, and all future phases) imports from the domain layer. Getting the types, enums, and validation right here prevents cascading bugs. This plan also establishes the project skeleton (uv, ruff, mypy, pytest configuration) so subsequent plans can focus purely on business logic.

Output: A working Python project with all domain types defined, validated by Pydantic models, and covered by unit tests. Running `pytest` and `mypy` both pass.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-domain-and-pricing-engine/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Python project with uv and configure tooling</name>
  <files>
    pyproject.toml
    .python-version
    src/negotiation/__init__.py
    src/negotiation/domain/__init__.py
    src/negotiation/pricing/__init__.py
    src/negotiation/state_machine/__init__.py
    tests/__init__.py
    tests/domain/__init__.py
  </files>
  <action>
    Initialize the Python project using `uv init` (or manually create pyproject.toml if uv is not installed). The project name is `influencer-negotiation-agent`.

    Create pyproject.toml with:
    - Python >= 3.12
    - Dependencies: pydantic >= 2.12, < 3
    - Dev dependencies: pytest >= 9.0, pytest-cov >= 6.0, ruff >= 0.15, mypy >= 1.19
    - [tool.pytest.ini_options]: testpaths = ["tests"], pythonpath = ["src"], addopts = "-v --tb=short"
    - [tool.ruff]: target-version = "py312", line-length = 100, src = ["src", "tests"]
    - [tool.ruff.lint]: select = ["E", "F", "W", "I", "N", "UP", "B", "SIM", "RUF"]
    - [tool.ruff.format]: quote-style = "double"
    - [tool.mypy]: python_version = "3.12", strict = true, warn_return_any = true, warn_unused_configs = true, plugins = ["pydantic.mypy"]
    - [[tool.mypy.overrides]]: module = "tests.*", disallow_untyped_defs = false

    Create .python-version containing "3.12".

    Create the directory structure with empty __init__.py files for:
    - src/negotiation/
    - src/negotiation/domain/
    - src/negotiation/pricing/
    - src/negotiation/state_machine/
    - tests/
    - tests/domain/

    Run `uv sync` (or `pip install -e ".[dev]"` if uv not available) to install dependencies into a virtual environment.

    Verify the tooling works by running: `uv run ruff check src/` and `uv run mypy src/` (both should pass with no files to check).
  </action>
  <verify>
    - `uv run python -c "import pydantic; print(pydantic.__version__)"` prints a 2.x version
    - `uv run pytest --co` runs without error (collects 0 tests)
    - `uv run ruff check src/` exits 0
    - `uv run mypy src/` exits 0 (or reports no files to check)
  </verify>
  <done>Project skeleton exists with all dependencies installed, all tooling configured and passing, and the directory structure matches the research-recommended layout.</done>
</task>

<task type="auto">
  <name>Task 2: Create domain types, models, errors, and tests</name>
  <files>
    src/negotiation/domain/types.py
    src/negotiation/domain/models.py
    src/negotiation/domain/errors.py
    src/negotiation/domain/__init__.py
    tests/conftest.py
    tests/domain/test_types.py
    tests/domain/test_models.py
  </files>
  <action>
    **types.py** -- Define three StrEnum classes:

    1. `Platform(StrEnum)` with members: INSTAGRAM = "instagram", TIKTOK = "tiktok", YOUTUBE = "youtube"

    2. `DeliverableType(StrEnum)` with members:
       - Instagram: INSTAGRAM_POST, INSTAGRAM_STORY, INSTAGRAM_REEL
       - TikTok: TIKTOK_VIDEO, TIKTOK_STORY
       - YouTube: YOUTUBE_DEDICATED, YOUTUBE_INTEGRATION, YOUTUBE_SHORT

    3. `NegotiationState(StrEnum)` with members: INITIAL_OFFER, AWAITING_REPLY, COUNTER_RECEIVED, COUNTER_SENT, AGREED, REJECTED, ESCALATED, STALE

    Also define `PLATFORM_DELIVERABLES: dict[Platform, set[DeliverableType]]` mapping each platform to its valid deliverable types. Add helper functions:
    - `get_platform_for_deliverable(deliverable_type: DeliverableType) -> Platform`
    - `validate_platform_deliverable(platform: Platform, deliverable_type: DeliverableType) -> None` (raises ValueError on mismatch)

    **errors.py** -- Define domain exceptions:
    - `NegotiationError(Exception)` -- base class for all domain errors
    - `InvalidTransitionError(NegotiationError)` -- stores current_state and event, descriptive message
    - `InvalidDeliverableError(NegotiationError)` -- stores platform and deliverable_type
    - `PricingError(NegotiationError)` -- for pricing calculation failures

    **models.py** -- Define Pydantic v2 models with strict validation:

    1. `PayRange(BaseModel)` with frozen=True:
       - min_rate: Decimal (dollar amount at $20 CPM floor)
       - max_rate: Decimal (dollar amount at $30 CPM ceiling)
       - average_views: int (must be positive)
       - field_validator for min_rate/max_rate that rejects float inputs (raises ValueError with message "Use Decimal or string, not float, for monetary values")
       - field_validator for average_views that enforces > 0
       - model_validator that enforces min_rate <= max_rate

    2. `Deliverable(BaseModel)` with frozen=True:
       - platform: Platform
       - deliverable_type: DeliverableType
       - quantity: int (default 1, must be >= 1)
       - model_validator that calls validate_platform_deliverable to ensure type matches platform

    3. `NegotiationContext(BaseModel)`:
       - influencer_name: str (non-empty)
       - average_views: int (positive)
       - deliverables: list[Deliverable] (non-empty)
       - pay_range: PayRange
       - current_state: NegotiationState (default INITIAL_OFFER)
       - notes: str | None (default None)

    Update `domain/__init__.py` to re-export all public types.

    **conftest.py** -- Create shared pytest fixtures:
    - `sample_pay_range()` returning PayRange(min_rate=Decimal("1000"), max_rate=Decimal("1500"), average_views=50000)
    - `sample_deliverable()` returning Deliverable(platform=Platform.INSTAGRAM, deliverable_type=DeliverableType.INSTAGRAM_REEL)
    - `sample_context()` using the above fixtures

    **test_types.py** -- Test all enums:
    - Test Platform has exactly 3 members
    - Test DeliverableType has exactly 8 members
    - Test NegotiationState has exactly 8 members
    - Test each enum serializes to/from string correctly
    - Test PLATFORM_DELIVERABLES maps all 8 deliverable types
    - Test get_platform_for_deliverable returns correct platform for each type
    - Test validate_platform_deliverable raises ValueError for mismatched pairs (e.g., INSTAGRAM_REEL on YOUTUBE)
    - Test validate_platform_deliverable passes for all valid pairs

    **test_models.py** -- Test all Pydantic models:
    - PayRange: valid creation with Decimal strings, rejection of float inputs (raises ValidationError), rejection of negative average_views, rejection of min_rate > max_rate
    - PayRange: test frozen (immutable) behavior
    - Deliverable: valid creation, rejection of mismatched platform/deliverable_type pairs
    - NegotiationContext: valid creation, rejection of empty influencer_name, rejection of empty deliverables list
    - Test serialization round-trip (model_dump / model_validate)
  </action>
  <verify>
    - `uv run pytest tests/domain/ -v` -- all tests pass
    - `uv run mypy src/negotiation/domain/` -- no type errors
    - `uv run ruff check src/negotiation/domain/` -- no lint errors
  </verify>
  <done>All domain types (3 enums, 3 models, 4 exception classes) are defined with strict validation. Tests cover enum membership, platform-deliverable validation, model creation with valid/invalid inputs, float rejection, and immutability. pytest, mypy, and ruff all pass clean.</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/ -v --tb=short` passes all tests
- `uv run mypy src/` reports no errors
- `uv run ruff check src/ tests/` reports no issues
- `uv run python -c "from negotiation.domain import Platform, DeliverableType, NegotiationState, PayRange, Deliverable"` succeeds
</verification>

<success_criteria>
1. Python project exists with pyproject.toml, uv lockfile, and all dependencies installed
2. Domain types (Platform, DeliverableType, NegotiationState) are importable and have correct members
3. Pydantic models (PayRange, Deliverable, NegotiationContext) validate inputs strictly (reject floats, enforce positive views, validate platform-deliverable pairs)
4. All domain tests pass, mypy strict mode passes, ruff passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-domain-and-pricing-engine/01-01-SUMMARY.md`
</output>
