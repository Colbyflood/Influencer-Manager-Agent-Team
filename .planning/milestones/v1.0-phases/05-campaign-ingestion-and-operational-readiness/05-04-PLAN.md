---
phase: 05-campaign-ingestion-and-operational-readiness
plan: 04
type: execute
wave: 3
depends_on:
  - 05-02
  - 05-03
files_modified:
  - src/negotiation/app.py
  - src/negotiation/audit/wiring.py
  - tests/test_app.py
  - tests/audit/test_wiring.py
autonomous: true
requirements:
  - DATA-01
  - DATA-03
  - DATA-04

must_haves:
  truths:
    - "Application entry point runs both FastAPI webhook server and Slack Bolt Socket Mode handler concurrently"
    - "Audit logging is wired into the negotiation loop so every email send/receive is automatically logged"
    - "Campaign ingestion webhook triggers negotiation start for found influencers with audit logging"
    - "All external API calls (Gmail, Slack, ClickUp, Anthropic) have retry logic with Slack error notification"
    - "Structured logging (structlog) is configured for production JSON output and development console output"
  artifacts:
    - path: "src/negotiation/app.py"
      provides: "Application entry point combining FastAPI + Slack Bolt with structlog config"
      min_lines: 80
    - path: "src/negotiation/audit/wiring.py"
      provides: "Audit integration functions that wrap existing pipeline functions with logging"
      min_lines: 60
    - path: "tests/test_app.py"
      provides: "Tests for application setup, structlog config, and service initialization"
      min_lines: 40
    - path: "tests/audit/test_wiring.py"
      provides: "Tests for audit wiring into negotiation pipeline"
      min_lines: 60
  key_links:
    - from: "src/negotiation/app.py"
      to: "src/negotiation/campaign/webhook.py"
      via: "mounts FastAPI app for webhook handling"
      pattern: "fastapi_app|webhook.*app|uvicorn"
    - from: "src/negotiation/app.py"
      to: "src/negotiation/slack/app.py"
      via: "starts Slack Bolt Socket Mode handler"
      pattern: "create_slack_app|start_slack_app|SocketMode"
    - from: "src/negotiation/audit/wiring.py"
      to: "src/negotiation/audit/logger.py"
      via: "uses AuditLogger to insert entries at pipeline integration points"
      pattern: "AuditLogger|log_email_sent|log_email_received|log_escalation|log_agreement"
    - from: "src/negotiation/app.py"
      to: "src/negotiation/resilience/retry.py"
      via: "configures error notifier for retry exhaustion"
      pattern: "configure_error_notifier|resilient_api_call"
---

<objective>
Create the application entry point that combines all Phase 5 components (webhook server, Slack handler, audit trail, retry logic) into a production-ready long-running process, and wire audit logging into the existing negotiation pipeline.

Purpose: This final plan integrates everything: the ClickUp webhook triggers campaign ingestion which starts negotiations with audit logging at every step, the Slack handler serves /audit queries and slash commands, and all external API calls have retry logic. The system is production-ready.

Output: Single application entry point (app.py), audit wiring module connecting logger to existing pipeline, structlog configuration, and full integration tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-campaign-ingestion-and-operational-readiness/05-RESEARCH.md
@.planning/phases/05-campaign-ingestion-and-operational-readiness/05-01-SUMMARY.md
@.planning/phases/05-campaign-ingestion-and-operational-readiness/05-02-SUMMARY.md
@.planning/phases/05-campaign-ingestion-and-operational-readiness/05-03-SUMMARY.md

# Components to wire together
@src/negotiation/campaign/webhook.py
@src/negotiation/campaign/ingestion.py
@src/negotiation/audit/logger.py
@src/negotiation/audit/store.py
@src/negotiation/audit/slack_commands.py
@src/negotiation/resilience/retry.py

# Existing Slack app setup
@src/negotiation/slack/app.py
@src/negotiation/slack/commands.py
@src/negotiation/slack/dispatcher.py

# Existing negotiation loop to wire audit into
@src/negotiation/llm/negotiation_loop.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit wiring module connecting logger to existing negotiation pipeline</name>
  <files>
    src/negotiation/audit/wiring.py
    src/negotiation/audit/__init__.py
    tests/audit/test_wiring.py
  </files>
  <action>
    1. Create `src/negotiation/audit/wiring.py`:
       This module provides wrapper functions that add audit logging around existing pipeline operations. The wrappers call the original function AND log the action, without modifying the original modules. This avoids touching complex existing code while still achieving comprehensive logging.

       - `create_audited_email_send(original_send: Callable, audit_logger: AuditLogger) -> Callable`: Returns a wrapper function that calls original_send and then calls audit_logger.log_email_sent with the email details (influencer name, thread ID, email body, negotiation state, rates). Extract campaign_id from negotiation context if available.

       - `create_audited_email_receive(original_receive: Callable, audit_logger: AuditLogger) -> Callable`: Returns a wrapper that calls original_receive and then calls audit_logger.log_email_received with received email details (influencer name, thread ID, body, intent classification).

       - `create_audited_process_reply(original_process: Callable, audit_logger: AuditLogger) -> Callable`: Returns a wrapper around process_influencer_reply that:
         a. Calls original_process
         b. Based on the returned action dict, logs the appropriate event:
            - action="send" -> log_email_sent (the counter-offer)
            - action="escalate" -> log_escalation (with reason)
            - action="accept" -> log_agreement (with agreed rate)
            - action="reject" -> log_state_transition (to rejected)
         c. Returns the original action dict unchanged

       - `wire_audit_to_campaign_ingestion(ingest_fn: Callable, audit_logger: AuditLogger) -> Callable`: Returns a wrapper around ingest_campaign that:
         a. Calls original ingest_fn
         b. Logs campaign_start with influencer counts
         c. Logs campaign_influencer_skip for each missing influencer
         d. Returns original result unchanged

       - `wire_audit_to_dispatcher(dispatcher: Any, audit_logger: AuditLogger) -> None`: Monkey-patches or wraps the SlackDispatcher methods to log:
         - dispatch_escalation -> log_escalation
         - dispatch_agreement -> log_agreement
         - pre_check human takeover -> log_takeover
         NOTE: Prefer the wrapper pattern (create new methods that call original + log) over modifying SlackDispatcher source code.

    2. Update `src/negotiation/audit/__init__.py` to add wiring exports.

    3. Create `tests/audit/test_wiring.py`:
       - Use tmp_path for SQLite database in all tests
       - Test create_audited_email_send calls original AND inserts audit entry
       - Test create_audited_email_receive calls original AND inserts audit entry with intent
       - Test create_audited_process_reply with action="send" logs email_sent
       - Test create_audited_process_reply with action="escalate" logs escalation
       - Test create_audited_process_reply with action="accept" logs agreement
       - Test wire_audit_to_campaign_ingestion logs campaign_start with correct counts
       - Test wire_audit_to_campaign_ingestion logs skip for each missing influencer
       - Verify original function return values are passed through unchanged by all wrappers
       - Use mock functions for original_send, original_receive, original_process

    Verify: `uv run pytest tests/audit/test_wiring.py -v` passes, quality gates pass.
  </action>
  <verify>
    `uv run pytest tests/audit/test_wiring.py -v` passes all tests.
    `uv run ruff check src/negotiation/audit/wiring.py` reports no issues.
    `uv run mypy src/negotiation/audit/wiring.py` reports no errors.
  </verify>
  <done>
    Audit wiring module provides wrapper functions that add logging to existing pipeline operations without modifying original source code. Email send/receive, process_influencer_reply, campaign ingestion, and dispatcher methods are all wrapped with appropriate audit logging. Original return values pass through unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Application entry point with FastAPI + Slack Bolt + structlog + retry configuration</name>
  <files>
    src/negotiation/app.py
    tests/test_app.py
  </files>
  <action>
    1. Create `src/negotiation/app.py`:
       Per RESEARCH discretion: Long-running process model with asyncio combining FastAPI (HTTP) and Slack Bolt (WebSocket).

       - `configure_logging(production: bool = False) -> None`: Configure structlog with:
         - Production mode (PRODUCTION env var or production=True): JSON rendering, INFO level
         - Development mode: Console rendering (colored, human-readable), DEBUG level
         - Bind common context: service="negotiation-agent"
         Per CLAUDE'S DISCRETION: structlog dual-mode configuration.

       - `initialize_services() -> dict[str, Any]`: Set up all shared services:
         a. Initialize SQLite audit database (init_audit_db with AUDIT_DB_PATH env var, default "data/audit.db"). Create data/ directory if not exists.
         b. Create AuditLogger with the database connection
         c. Create SlackNotifier (if SLACK_BOT_TOKEN available)
         d. Configure resilience error notifier (configure_error_notifier with SlackNotifier)
         e. Create SheetsClient (if credentials available)
         f. Register audit command on Slack Bolt app (register_audit_command)
         g. Register existing /claim and /resume commands (register_commands from slack.commands)
         h. Wire audit logging into pipeline functions (from audit.wiring)
         i. Return dict of initialized services for access by webhook handlers

       - `create_app(services: dict[str, Any]) -> FastAPI`: Get or create the FastAPI app from campaign.webhook module. Add startup/shutdown event handlers for audit DB connection management. Add middleware or dependencies to inject services into webhook handler.

       - `async def run_slack_bot(services: dict[str, Any]) -> None`: Start Slack Bolt Socket Mode handler in a background thread using asyncio.to_thread (since Bolt Socket Mode is synchronous). Wrap in try/except to log errors.

       - `async def main() -> None`: Main entry point:
         a. Configure logging
         b. Initialize services
         c. Create FastAPI app
         d. Create uvicorn.Config and Server for FastAPI (host=0.0.0.0, port from WEBHOOK_PORT env var default 8000)
         e. Run both uvicorn.Server.serve() and run_slack_bot() concurrently with asyncio.gather()
         f. Handle graceful shutdown (close audit DB on exit)

       - `if __name__ == "__main__": asyncio.run(main())`

       Per LOCKED DECISIONS:
       - Retry on API failures: 3 times with backoff, then Slack #errors (handled by resilience.retry, configured here)
       - One-way ClickUp flow (webhook receives, no sync back)
       - Auto-start negotiations on webhook receipt

       Per CLAUDE'S DISCRETION:
       - Runtime: long-running process (constraints: Slack Socket Mode needs persistent WebSocket, SQLite needs local filesystem, ThreadStateManager uses in-memory state)
       - Config: hybrid (env vars for secrets, YAML for business logic) -- already established
       - Logging: structlog with JSON (prod) / console (dev)
       - Retry: exponential with jitter (1s initial, 30s max, 5s jitter) via tenacity

    2. Create `tests/test_app.py`:
       - Test configure_logging in development mode (structlog dev renderer)
       - Test configure_logging in production mode (structlog JSON renderer)
       - Test initialize_services creates audit DB connection (use tmp_path, mock external services)
       - Test initialize_services configures error notifier
       - Test create_app returns FastAPI instance
       - Test that main() can be imported without side effects
       - Mock all external service constructors (SlackNotifier, SheetsClient) to avoid requiring real credentials in tests
       - Test AUDIT_DB_PATH env var is respected (use monkeypatch)
       - Test WEBHOOK_PORT env var is respected (use monkeypatch)

    Verify: `uv run pytest tests/test_app.py tests/audit/ -v` passes, quality gates pass. Run full test suite: `uv run pytest` to verify no regressions.
  </action>
  <verify>
    `uv run pytest tests/test_app.py tests/audit/ -v` passes all tests.
    `uv run ruff check src/negotiation/app.py src/negotiation/audit/` reports no issues.
    `uv run mypy src/negotiation/app.py src/negotiation/audit/` reports no errors.
    `uv run pytest` -- full test suite passes (no regressions across all phases).
    `uv run python -c "from negotiation.app import main, configure_logging, initialize_services; print('App imports OK')"` succeeds.
  </verify>
  <done>
    Application entry point runs FastAPI (ClickUp webhooks on port 8000) and Slack Bolt (Socket Mode for /audit, /claim, /resume commands) concurrently in a single long-running process. Audit logging is wired into all pipeline operations via wrapper functions. Structured logging with structlog provides JSON output in production and colored console in development. Retry logic configured for all external APIs with Slack #errors notification on exhaustion. Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest` -- full test suite passes (all phases, no regressions)
- `uv run ruff check src/negotiation/` -- clean across entire source
- `uv run mypy src/negotiation/` -- no errors across entire source
- App entry point can start without real credentials (graceful degradation when services unavailable)
- Audit wiring wraps pipeline functions without modifying original source code
- structlog produces JSON in production mode and console in development mode
- Retry decorator applied to external API calls with 3 attempts and Slack notification
</verification>

<success_criteria>
- `python -m negotiation.app` starts the combined FastAPI + Slack Bolt server (or gracefully reports missing credentials)
- Every email sent/received in the negotiation loop is automatically logged to the audit trail
- Campaign ingestion from ClickUp webhook triggers negotiation start with audit logging
- All external API calls have retry logic per locked decision (3x backoff, then Slack #errors)
- /audit Slack command returns Block Kit formatted results
- CLI query interface works with all filter options
- Full test suite passes with no regressions from Phases 1-4
</success_criteria>

<output>
After completion, create `.planning/phases/05-campaign-ingestion-and-operational-readiness/05-04-SUMMARY.md`
</output>
