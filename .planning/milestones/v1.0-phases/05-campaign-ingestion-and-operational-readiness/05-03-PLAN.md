---
phase: 05-campaign-ingestion-and-operational-readiness
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/negotiation/audit/logger.py
  - src/negotiation/audit/cli.py
  - src/negotiation/audit/slack_commands.py
  - src/negotiation/audit/__init__.py
  - tests/audit/test_logger.py
  - tests/audit/test_cli.py
  - tests/audit/test_slack_commands.py
autonomous: true
requirements:
  - DATA-03
  - DATA-04

must_haves:
  truths:
    - "Every email sent and received is logged with timestamp, direction, email body, negotiation state, and rates used"
    - "Escalations, agreements, takeovers, campaign starts, and state transitions are all logged"
    - "Team can query audit trail by influencer name via CLI and get filtered results"
    - "Team can query audit trail by campaign ID via CLI and get filtered results"
    - "Team can query audit trail by date range via CLI and get filtered results"
    - "Team can use /audit Slack command for quick lookups with Block Kit formatted responses"
  artifacts:
    - path: "src/negotiation/audit/logger.py"
      provides: "AuditLogger class with convenience methods for each event type"
      min_lines: 80
    - path: "src/negotiation/audit/cli.py"
      provides: "CLI query interface with argparse (--influencer, --campaign, --from-date, --to-date, --event-type, --last, --format)"
      min_lines: 60
    - path: "src/negotiation/audit/slack_commands.py"
      provides: "Slack /audit command handler with Block Kit formatted responses"
      min_lines: 50
    - path: "tests/audit/test_logger.py"
      provides: "Tests for audit logger convenience methods"
      min_lines: 60
    - path: "tests/audit/test_cli.py"
      provides: "Tests for CLI query interface"
      min_lines: 40
    - path: "tests/audit/test_slack_commands.py"
      provides: "Tests for Slack /audit command handler"
      min_lines: 40
  key_links:
    - from: "src/negotiation/audit/logger.py"
      to: "src/negotiation/audit/store.py"
      via: "inserts entries via insert_audit_entry"
      pattern: "insert_audit_entry"
    - from: "src/negotiation/audit/cli.py"
      to: "src/negotiation/audit/store.py"
      via: "queries via query_audit_trail"
      pattern: "query_audit_trail"
    - from: "src/negotiation/audit/slack_commands.py"
      to: "src/negotiation/audit/store.py"
      via: "queries via query_audit_trail"
      pattern: "query_audit_trail"
---

<objective>
Create the audit logging interface layer and both query interfaces (CLI and Slack) for the conversation audit trail.

Purpose: DATA-03 requires logging every email and negotiation action, and DATA-04 requires queryable access by influencer, campaign, or date range. This plan creates the AuditLogger (convenience API for inserting entries), the CLI for detailed queries, and the Slack /audit command for quick team lookups.

Output: AuditLogger with typed convenience methods, argparse CLI for detailed audit queries, Slack /audit command with Block Kit formatting.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-campaign-ingestion-and-operational-readiness/05-RESEARCH.md
@.planning/phases/05-campaign-ingestion-and-operational-readiness/05-01-SUMMARY.md

# Audit store from Plan 01
@src/negotiation/audit/store.py
@src/negotiation/audit/models.py

# Slack app and command registration pattern from Phase 4
@src/negotiation/slack/app.py
@src/negotiation/slack/commands.py

# Existing Block Kit pattern
@src/negotiation/slack/blocks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: AuditLogger convenience class for inserting audit entries</name>
  <files>
    src/negotiation/audit/logger.py
    tests/audit/test_logger.py
  </files>
  <action>
    1. Create `src/negotiation/audit/logger.py`:
       - `AuditLogger` class:
         - __init__(conn: sqlite3.Connection): Store connection for audit inserts
         - `log_email_sent(campaign_id: str | None, influencer_name: str, thread_id: str, email_body: str, negotiation_state: str, rates_used: str | None = None, metadata: dict[str, str] | None = None) -> int`: Create AuditEntry with event_type=EventType.EMAIL_SENT, direction="sent", insert and return row ID.
         - `log_email_received(campaign_id: str | None, influencer_name: str, thread_id: str, email_body: str, negotiation_state: str, intent_classification: str | None = None, rates_used: str | None = None, metadata: dict[str, str] | None = None) -> int`: Create AuditEntry with event_type=EventType.EMAIL_RECEIVED, direction="received".
         - `log_state_transition(campaign_id: str | None, influencer_name: str, thread_id: str | None, from_state: str, to_state: str, event: str) -> int`: Log with event_type=EventType.STATE_TRANSITION. Store from_state, to_state, event in metadata dict.
         - `log_escalation(campaign_id: str | None, influencer_name: str, thread_id: str | None, reason: str, negotiation_state: str, rates_used: str | None = None) -> int`: Log with event_type=EventType.ESCALATION. Store reason in metadata.
         - `log_agreement(campaign_id: str | None, influencer_name: str, thread_id: str | None, agreed_rate: str, negotiation_state: str, metadata: dict[str, str] | None = None) -> int`: Log with event_type=EventType.AGREEMENT. Store agreed_rate in rates_used.
         - `log_takeover(campaign_id: str | None, influencer_name: str, thread_id: str, taken_by: str) -> int`: Log with event_type=EventType.TAKEOVER. Store taken_by in metadata.
         - `log_campaign_start(campaign_id: str, influencer_count: int, found_count: int, missing_count: int) -> int`: Log with event_type=EventType.CAMPAIGN_START. Store counts in metadata.
         - `log_campaign_influencer_skip(campaign_id: str, influencer_name: str, reason: str) -> int`: Log with event_type=EventType.CAMPAIGN_INFLUENCER_SKIP.
         - `log_error(campaign_id: str | None, influencer_name: str | None, error_message: str, context: str | None = None) -> int`: Log with event_type=EventType.ERROR.
       Per LOCKED DECISION: Log everything -- emails, escalations, takeovers, campaign starts, state transitions, agreement closures.

    2. Create `tests/audit/test_logger.py`:
       - Use tmp_path for SQLite database, init_audit_db in fixture
       - Test log_email_sent inserts with correct event_type, direction="sent", and all fields
       - Test log_email_received inserts with correct event_type, direction="received", intent_classification
       - Test log_state_transition stores from_state/to_state/event in metadata
       - Test log_escalation stores reason in metadata
       - Test log_agreement stores agreed_rate in rates_used
       - Test log_takeover stores taken_by in metadata
       - Test log_campaign_start stores influencer counts
       - Test log_campaign_influencer_skip stores skip reason
       - Test log_error stores error message and context
       - Verify each method returns a valid row ID > 0
       - Verify inserted entries are queryable via query_audit_trail

    Verify: `uv run pytest tests/audit/test_logger.py -v` passes, quality gates pass.
  </action>
  <verify>
    `uv run pytest tests/audit/test_logger.py -v` passes all tests.
    `uv run ruff check src/negotiation/audit/logger.py` reports no issues.
    `uv run mypy src/negotiation/audit/logger.py` reports no errors.
  </verify>
  <done>
    AuditLogger provides typed convenience methods for all 9 event types. Each method creates a properly structured AuditEntry and inserts it into the SQLite audit store. Every event type from the locked decisions is covered: emails, escalations, takeovers, campaign starts, state transitions, agreements, skips, and errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI query interface and Slack /audit command</name>
  <files>
    src/negotiation/audit/cli.py
    src/negotiation/audit/slack_commands.py
    src/negotiation/audit/__init__.py
    tests/audit/test_cli.py
    tests/audit/test_slack_commands.py
  </files>
  <action>
    1. Create `src/negotiation/audit/cli.py`:
       - `build_parser() -> argparse.ArgumentParser`: Create parser with description "Query negotiation audit trail". Arguments:
         - `--influencer`: Filter by influencer name (case-insensitive matching)
         - `--campaign`: Filter by campaign ID
         - `--from-date`: Start date (YYYY-MM-DD)
         - `--to-date`: End date (YYYY-MM-DD)
         - `--event-type`: Filter by event type (choices from EventType enum)
         - `--last`: Shorthand duration (e.g., "7d", "24h", "30d") -- parse into from_date
         - `--format`: Output format (choices: table, json), default "table"
         - `--limit`: Max results, default 50
         - `--db`: Path to audit database, default from AUDIT_DB_PATH env var or "data/audit.db"
       - `parse_last_duration(last: str) -> str`: Convert "7d" to ISO date string 7 days ago, "24h" to 24 hours ago, "30d" to 30 days ago. Raise ValueError on unrecognized format.
       - `format_table(results: list[dict[str, Any]]) -> str`: Format as human-readable table with columns: Timestamp, Event, Influencer, Campaign, State, Direction. Truncate long fields. Include header row.
       - `format_json(results: list[dict[str, Any]]) -> str`: Return `json.dumps(results, indent=2)`.
       - `def main() -> None`: Parse args, connect to audit DB, query, format, print. Entry point for `python -m negotiation.audit.cli`.
       - Add `__main__.py` support or use `if __name__ == "__main__": main()`.
       Per LOCKED DECISION: CLI for detailed queries by influencer, campaign, or date range.

    2. Create `src/negotiation/audit/slack_commands.py`:
       - `parse_audit_query(query_text: str) -> dict[str, str]`: Parse Slack command text like "influencer:Jane Doe last:7d" or "campaign:camp_123" into query parameters dict. Support keys: influencer, campaign, last, event_type.
       - `format_audit_blocks(results: list[dict[str, Any]], query_params: dict[str, str]) -> list[dict[str, Any]]`: Build Block Kit blocks for audit results. Per research discretion recommendation:
         - Header section with query summary ("Audit Trail: Jane Doe (last 7 days)")
         - Count line ("47 entries found (showing most recent 10)")
         - For each result (up to 10): section block with fields for timestamp, event type, campaign, state, direction, rates
         - If more results than shown: footer note "Showing 10 of N results. Use CLI for full results."
         - Block Kit limit: max 50 blocks per message, keep to ~10 entries for readability
       - `register_audit_command(app: Any, audit_db_conn: sqlite3.Connection) -> None`: Register `/audit` command on the Bolt app. Handler calls ack() immediately, parses query text, queries audit store, formats blocks, calls respond() with blocks.
       Follow existing command registration pattern from src/negotiation/slack/commands.py.

    3. Update `src/negotiation/audit/__init__.py` to export all public symbols alphabetically: AuditEntry, AuditLogger, EventType, build_parser, close_audit_db, format_audit_blocks, init_audit_db, insert_audit_entry, parse_audit_query, query_audit_trail, register_audit_command.

    4. Create `tests/audit/test_cli.py`:
       - Test build_parser accepts all arguments
       - Test parse_last_duration converts "7d" to correct date
       - Test parse_last_duration converts "24h" to correct date
       - Test parse_last_duration raises ValueError on invalid format
       - Test format_table produces readable output with header
       - Test format_json produces valid JSON
       - Test main() with --influencer flag (mock DB connection, verify query_audit_trail called with correct influencer)

    5. Create `tests/audit/test_slack_commands.py`:
       - Test parse_audit_query parses "influencer:Jane Doe" correctly
       - Test parse_audit_query parses "campaign:camp_123 last:7d" correctly
       - Test parse_audit_query handles empty input
       - Test format_audit_blocks produces Block Kit blocks with header and results
       - Test format_audit_blocks truncates to 10 results with "showing N of M" note
       - Test register_audit_command registers /audit on Bolt app (mock app.command)

    Verify: `uv run pytest tests/audit/ -v` passes all tests, quality gates pass.
  </action>
  <verify>
    `uv run pytest tests/audit/ -v` passes all tests (test_store.py from Plan 01 + test_logger.py from Task 1 + test_cli.py + test_slack_commands.py).
    `uv run ruff check src/negotiation/audit/` reports no issues.
    `uv run mypy src/negotiation/audit/` reports no errors.
    `uv run python -c "from negotiation.audit import AuditLogger, EventType, AuditEntry, init_audit_db, query_audit_trail, register_audit_command, build_parser; print('All exports OK')"` succeeds.
  </verify>
  <done>
    AuditLogger convenience methods cover all 9 event types. CLI interface queries audit trail with filters (--influencer, --campaign, --from-date, --to-date, --event-type, --last shorthand) and outputs as table or JSON. Slack /audit command parses "influencer:Name last:7d" syntax and responds with Block Kit formatted results (max 10 entries with overflow note). All registered via existing Bolt app pattern.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest tests/audit/ -v` -- all tests pass
- `uv run ruff check src/negotiation/audit/` -- clean
- `uv run mypy src/negotiation/audit/` -- no errors
- AuditLogger has convenience methods for all 9 event types
- CLI supports --influencer, --campaign, --from-date, --to-date, --event-type, --last, --format
- Slack /audit parses query text and returns Block Kit blocks
- Block Kit responses limited to 10 entries with "Use CLI for full results" overflow note
</verification>

<success_criteria>
- AuditLogger covers all event types per locked decision (emails, escalations, takeovers, campaign starts, state transitions, agreements)
- CLI outputs both table and JSON formats
- Slack /audit command responds with Block Kit formatted results
- All audit queries filter correctly by influencer, campaign, and date range
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-campaign-ingestion-and-operational-readiness/05-03-SUMMARY.md`
</output>
