---
phase: 06-runtime-orchestration-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/negotiation/app.py
  - src/negotiation/campaign/webhook.py
autonomous: true
requirements: []
gap_closure: true

must_haves:
  truths:
    - "FastAPI app uses lifespan context manager instead of deprecated on_event handlers"
    - "GmailClient is initialized in initialize_services when GMAIL_TOKEN_PATH is set"
    - "SlackDispatcher is instantiated with SlackNotifier, ThreadStateManager, triggers config, and agent email"
    - "Anthropic client is initialized when ANTHROPIC_API_KEY is available"
    - "Gmail Pub/Sub push notification endpoint exists at POST /webhooks/gmail"
    - "Inbound email triggers fetch_new_messages, get_message, pre_check, process_influencer_reply, handle_negotiation_result, and send_reply"
    - "Gmail watch is registered on startup and renewed every 6 days"
    - "All GmailClient calls in async contexts use asyncio.to_thread"
    - "History ID is tracked with asyncio.Lock to prevent race conditions"
    - "In-memory negotiation state dict tracks active negotiations by thread_id"
  artifacts:
    - path: "src/negotiation/app.py"
      provides: "Full runtime orchestration with lifespan, Gmail handler, SlackDispatcher, negotiation pipeline"
      contains: "async def lifespan"
    - path: "src/negotiation/campaign/webhook.py"
      provides: "Router pattern for ClickUp webhook routes"
      contains: "APIRouter"
  key_links:
    - from: "src/negotiation/app.py"
      to: "negotiation.email.client.GmailClient"
      via: "import and initialization in initialize_services"
      pattern: "GmailClient"
    - from: "src/negotiation/app.py"
      to: "negotiation.slack.dispatcher.SlackDispatcher"
      via: "import and initialization in initialize_services"
      pattern: "SlackDispatcher"
    - from: "src/negotiation/app.py"
      to: "negotiation.llm.negotiation_loop.process_influencer_reply"
      via: "called inside process_inbound_email"
      pattern: "process_influencer_reply"
    - from: "src/negotiation/app.py /webhooks/gmail"
      to: "process_inbound_email"
      via: "background task spawned from gmail_notification handler"
      pattern: "process_inbound_email"
---

<objective>
Wire the inbound email pipeline, SlackDispatcher, and core service initialization into app.py. Replace deprecated FastAPI on_event with lifespan. Add Gmail Pub/Sub webhook endpoint and the process_inbound_email function that connects GmailClient -> pre_check -> process_influencer_reply -> handle_negotiation_result -> send_reply.

Purpose: Closes MISSING-01 (process_influencer_reply never called), MISSING-02 (no inbound email entry point), MISSING-03 (SlackDispatcher never instantiated), and tech debt (deprecated on_event). This is the largest and most critical gap -- it makes the negotiation pipeline actually run at runtime.

Output: Modified app.py with full inbound email pipeline, modified webhook.py converted to Router pattern.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-runtime-orchestration-wiring/06-RESEARCH.md
@src/negotiation/app.py
@src/negotiation/campaign/webhook.py
@src/negotiation/email/client.py
@src/negotiation/slack/dispatcher.py
@src/negotiation/llm/negotiation_loop.py
@src/negotiation/audit/wiring.py
@src/negotiation/slack/triggers.py
@src/negotiation/llm/client.py
@src/negotiation/auth/credentials.py
@tests/test_app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert webhook.py to Router pattern and add lifespan + service initialization to app.py</name>
  <files>src/negotiation/campaign/webhook.py, src/negotiation/app.py</files>
  <action>
**webhook.py changes:**
Convert `webhook.py` from creating its own `FastAPI()` app to using `APIRouter`:
1. Replace `app = FastAPI(title="Negotiation Agent Webhooks")` with `router = APIRouter()`.
2. Change `@app.post("/webhooks/clickup")` to `@router.post("/webhooks/clickup")`.
3. Change `@app.get("/health")` to `@router.get("/health")`.
4. Keep module-level `_campaign_processor` and `set_campaign_processor` unchanged.
5. Update the module's exports: the old `app` is now `router`. Update any `__all__` if present.

**app.py changes -- service initialization:**
Extend `initialize_services()` to create new services (following the existing graceful degradation pattern with try/except and None fallbacks):

a. **GmailClient** -- when `GMAIL_TOKEN_PATH` env var is set:
   ```python
   gmail_client = None
   gmail_token = os.environ.get("GMAIL_TOKEN_PATH")
   if gmail_token:
       try:
           from negotiation.auth.credentials import get_gmail_service
           from negotiation.email.client import GmailClient
           service = get_gmail_service()
           agent_email = os.environ.get("AGENT_EMAIL", "")
           gmail_client = GmailClient(service, agent_email)
           logger.info("GmailClient initialized")
       except Exception:
           logger.warning("Failed to initialize GmailClient", exc_info=True)
   else:
       logger.info("GMAIL_TOKEN_PATH not set, GmailClient disabled")
   services["gmail_client"] = gmail_client
   ```

b. **Anthropic client** -- when `ANTHROPIC_API_KEY` env var is set:
   ```python
   anthropic_client = None
   if os.environ.get("ANTHROPIC_API_KEY"):
       try:
           from negotiation.llm.client import get_anthropic_client
           anthropic_client = get_anthropic_client()
           logger.info("Anthropic client initialized")
       except Exception:
           logger.warning("Failed to initialize Anthropic client", exc_info=True)
   else:
       logger.info("ANTHROPIC_API_KEY not set, Anthropic client disabled")
   services["anthropic_client"] = anthropic_client
   ```

c. **SlackDispatcher** -- when `slack_notifier` AND `thread_state_manager` are available:
   ```python
   slack_dispatcher = None
   if slack_notifier is not None and thread_state_manager is not None:
       try:
           from negotiation.slack.dispatcher import SlackDispatcher
           from negotiation.slack.triggers import load_triggers_config
           triggers_config = load_triggers_config()
           agent_email = os.environ.get("AGENT_EMAIL", "")
           slack_dispatcher = SlackDispatcher(
               notifier=slack_notifier,
               thread_state_manager=thread_state_manager,
               triggers_config=triggers_config,
               agent_email=agent_email,
           )
           logger.info("SlackDispatcher initialized")
       except Exception:
           logger.warning("Failed to initialize SlackDispatcher", exc_info=True)
   else:
       logger.info("SlackNotifier or ThreadStateManager unavailable, SlackDispatcher disabled")
   services["slack_dispatcher"] = slack_dispatcher
   ```
   NOTE: `thread_state_manager` is already created in the existing bolt_app block. Move `thread_state_manager = ThreadStateManager()` creation BEFORE the SlackDispatcher block so it is available regardless of whether bolt_app exists. The ThreadStateManager is used by SlackDispatcher independently of Bolt.

d. **Negotiation state store** -- in-memory dict:
   ```python
   negotiation_states: dict[str, dict[str, Any]] = {}
   services["negotiation_states"] = negotiation_states
   ```

e. **History ID lock** -- asyncio.Lock for thread-safe history ID updates:
   ```python
   services["history_lock"] = asyncio.Lock()
   services["history_id"] = ""
   ```

f. **Wire audit to dispatcher** -- if both dispatcher and audit_logger exist:
   ```python
   if slack_dispatcher is not None:
       from negotiation.audit.wiring import wire_audit_to_dispatcher
       wire_audit_to_dispatcher(slack_dispatcher, audit_logger)
       logger.info("Audit logging wired to SlackDispatcher")
   ```

g. **Wire audited process_reply** -- create audited version:
   ```python
   from negotiation.audit.wiring import create_audited_process_reply
   from negotiation.llm.negotiation_loop import process_influencer_reply
   audited_process_reply = create_audited_process_reply(process_influencer_reply, audit_logger)
   services["audited_process_reply"] = audited_process_reply
   ```

**app.py changes -- lifespan:**
Replace the `create_app` function. Remove `from negotiation.campaign.webhook import app as webhook_app`. Instead import the router: `from negotiation.campaign.webhook import router as webhook_router`.

Create a `lifespan` async context manager:
```python
from contextlib import asynccontextmanager
from collections.abc import AsyncGenerator

@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None]:
    # Startup
    services = app.state.services
    gmail_client = services.get("gmail_client")
    if gmail_client:
        topic = os.environ.get("GMAIL_PUBSUB_TOPIC", "")
        if topic:
            try:
                watch_result = await asyncio.to_thread(gmail_client.setup_watch, topic)
                async with services["history_lock"]:
                    services["history_id"] = str(watch_result.get("historyId", ""))
                logger.info("Gmail watch registered", history_id=services["history_id"])
            except Exception:
                logger.warning("Failed to register Gmail watch", exc_info=True)
    logger.info("FastAPI application starting")
    yield
    # Shutdown
    audit_conn = services.get("audit_conn")
    if audit_conn is not None:
        close_audit_db(audit_conn)
        logger.info("Audit database connection closed")
```

Replace `create_app`:
```python
def create_app(services: dict[str, Any]) -> FastAPI:
    fastapi_app = FastAPI(title="Negotiation Agent Webhooks", lifespan=lifespan)
    fastapi_app.state.services = services
    fastapi_app.include_router(webhook_router)
    # Add Gmail webhook route (defined below)
    # ... register gmail_notification route on fastapi_app
    return fastapi_app
```

Remove the old `@fastapi_app.on_event("startup")` and `@fastapi_app.on_event("shutdown")` handlers entirely.
  </action>
  <verify>
1. `python -c "from negotiation.campaign.webhook import router; print(type(router))"` prints `<class 'fastapi.routing.APIRouter'>`.
2. `python -c "from negotiation.app import create_app, initialize_services"` imports without error.
3. `cd /Users/colbyflood/Influencer\ Manager\ Agent\ Team/Influencer-Manager-Agent-Team && python -m pytest tests/test_app.py -x -q` -- existing tests pass (may need minor updates for Router change).
4. `grep -c "on_event" src/negotiation/app.py` returns 0 (no deprecated pattern).
5. `grep "lifespan" src/negotiation/app.py` shows the lifespan function.
  </verify>
  <done>
app.py initializes GmailClient, Anthropic client, SlackDispatcher, negotiation_states dict, history_lock, and audited wrappers. Lifespan replaces deprecated on_event. webhook.py uses APIRouter. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Gmail Pub/Sub webhook endpoint and inbound email processing pipeline</name>
  <files>src/negotiation/app.py</files>
  <action>
Add the following functions to app.py:

**1. Gmail Pub/Sub notification endpoint** -- register on the FastAPI app in `create_app`:
```python
import base64
import json

@fastapi_app.post("/webhooks/gmail")
async def gmail_notification(request: Request) -> dict[str, str]:
    """Handle Gmail Pub/Sub push notification."""
    services = request.app.state.services
    gmail_client = services.get("gmail_client")
    if gmail_client is None:
        logger.warning("Gmail notification received but GmailClient not initialized")
        return {"status": "ok"}

    body = await request.json()
    message_data = body.get("message", {}).get("data", "")
    if not message_data:
        logger.warning("Gmail notification missing message data")
        return {"status": "ok"}

    decoded = json.loads(base64.urlsafe_b64decode(message_data))
    notification_history_id = decoded.get("historyId", "")
    logger.info("Gmail notification received", history_id=notification_history_id)

    # Fetch new messages under lock to prevent race conditions
    async with services["history_lock"]:
        current_history_id = services.get("history_id", "")
        if not current_history_id:
            logger.warning("No history ID stored, skipping notification")
            return {"status": "ok"}

        new_ids, new_history_id = await asyncio.to_thread(
            gmail_client.fetch_new_messages, current_history_id
        )
        services["history_id"] = new_history_id

    # Process each new message in background tasks
    background_tasks = services.get("background_tasks", set())
    for msg_id in new_ids:
        task = asyncio.ensure_future(
            process_inbound_email(msg_id, services)
        )
        background_tasks.add(task)
        task.add_done_callback(background_tasks.discard)

    logger.info("Gmail notification processed", new_messages=len(new_ids))
    return {"status": "ok"}
```

Add `from fastapi import FastAPI, Request` import at the top of app.py (Request is needed).

**2. Inbound email processing function:**
```python
async def process_inbound_email(message_id: str, services: dict[str, Any]) -> None:
    """Process a single inbound email through the full negotiation pipeline.

    Flow: get_message -> pre_check -> process_influencer_reply -> handle_result -> send_reply
    All GmailClient calls wrapped in asyncio.to_thread (they are synchronous).
    """
    gmail_client = services["gmail_client"]
    dispatcher = services.get("slack_dispatcher")
    anthropic_client = services.get("anthropic_client")
    negotiation_states = services.get("negotiation_states", {})
    audited_process_reply = services.get("audited_process_reply")

    try:
        # Step 1: Fetch and parse the email (blocking -> thread)
        inbound = await asyncio.to_thread(gmail_client.get_message, message_id)
        logger.info(
            "Processing inbound email",
            message_id=message_id,
            thread_id=inbound.thread_id,
            from_email=inbound.from_email,
        )

        # Step 2: Look up existing negotiation state by thread_id
        thread_state = negotiation_states.get(inbound.thread_id)
        if thread_state is None:
            logger.info(
                "No active negotiation for thread, ignoring",
                thread_id=inbound.thread_id,
            )
            return

        state_machine = thread_state["state_machine"]
        context = thread_state["context"]
        round_count = thread_state["round_count"]

        # Step 3: Run pre-check gates (if SlackDispatcher available)
        if dispatcher is not None:
            pre_check_result = dispatcher.pre_check(
                email_body=inbound.body_text,
                thread_id=inbound.thread_id,
                influencer_email=inbound.from_email,
                proposed_cpm=0.0,  # Unknown before classification; only human takeover gates fire
                intent_confidence=1.0,  # Default before classification
                gmail_service=gmail_client._service,
                anthropic_client=anthropic_client,
            )
            if pre_check_result is not None:
                logger.info(
                    "Pre-check gate fired, skipping negotiation",
                    action=pre_check_result.get("action"),
                    reason=pre_check_result.get("reason"),
                    thread_id=inbound.thread_id,
                )
                return

        # Step 4: Run negotiation loop
        if anthropic_client is None:
            logger.warning("Anthropic client unavailable, cannot process reply")
            return

        process_fn = audited_process_reply or services.get("_raw_process_reply")
        if process_fn is None:
            from negotiation.llm.negotiation_loop import process_influencer_reply
            process_fn = process_influencer_reply

        result = process_fn(
            email_body=inbound.body_text,
            negotiation_context=context,
            state_machine=state_machine,
            client=anthropic_client,
            round_count=round_count,
        )

        # Step 5: Dispatch to Slack (if dispatcher available)
        if dispatcher is not None:
            result = dispatcher.handle_negotiation_result(result, context)

        # Step 6: If action is "send", send the reply
        if result["action"] == "send":
            await asyncio.to_thread(
                gmail_client.send_reply,
                inbound.thread_id,
                result["email_body"],
            )
            thread_state["round_count"] += 1
            logger.info(
                "Counter-offer sent",
                thread_id=inbound.thread_id,
                round=thread_state["round_count"],
            )
        elif result["action"] == "accept":
            logger.info(
                "Deal accepted",
                thread_id=inbound.thread_id,
                influencer=context.get("influencer_name"),
            )
        elif result["action"] == "escalate":
            logger.info(
                "Escalated to human",
                thread_id=inbound.thread_id,
                reason=result.get("reason"),
            )
        elif result["action"] == "reject":
            logger.info(
                "Influencer rejected",
                thread_id=inbound.thread_id,
            )

    except Exception:
        logger.exception("Failed to process inbound email", message_id=message_id)
```

**3. Gmail watch renewal background task:**
```python
async def renew_gmail_watch_periodically(services: dict[str, Any]) -> None:
    """Renew Gmail watch every 6 days (watch expires at 7 days)."""
    interval_seconds = 6 * 24 * 3600  # 6 days
    gmail_client = services.get("gmail_client")
    topic = os.environ.get("GMAIL_PUBSUB_TOPIC", "")

    if not gmail_client or not topic:
        return

    while True:
        await asyncio.sleep(interval_seconds)
        try:
            result = await asyncio.to_thread(gmail_client.setup_watch, topic)
            async with services["history_lock"]:
                new_history_id = str(result.get("historyId", ""))
                if new_history_id:
                    services["history_id"] = new_history_id
            logger.info("Gmail watch renewed", history_id=services.get("history_id"))
        except Exception:
            logger.exception("Failed to renew Gmail watch")
```

**4. Update `main()` to add watch renewal to asyncio.gather:**
```python
async def main() -> None:
    # ... existing setup ...
    try:
        tasks_to_run = [server.serve(), run_slack_bot(services)]
        # Add Gmail watch renewal if Gmail is configured
        gmail_client = services.get("gmail_client")
        gmail_topic = os.environ.get("GMAIL_PUBSUB_TOPIC", "")
        if gmail_client and gmail_topic:
            tasks_to_run.append(renew_gmail_watch_periodically(services))
        await asyncio.gather(*tasks_to_run)
    finally:
        # ... existing cleanup ...
```
  </action>
  <verify>
1. `python -c "from negotiation.app import process_inbound_email, renew_gmail_watch_periodically; print('OK')"` imports successfully.
2. `grep -c "asyncio.to_thread" src/negotiation/app.py` returns >= 4 (setup_watch, fetch_new_messages, get_message, send_reply).
3. `grep "webhooks/gmail" src/negotiation/app.py` shows the Pub/Sub endpoint.
4. `grep "history_lock" src/negotiation/app.py` shows lock usage around history ID.
5. `cd /Users/colbyflood/Influencer\ Manager\ Agent\ Team/Influencer-Manager-Agent-Team && python -m pytest tests/ -x -q` -- all tests pass.
6. `python -m ruff check src/negotiation/app.py src/negotiation/campaign/webhook.py` -- no lint errors.
7. `python -m mypy src/negotiation/app.py --strict` -- no type errors (or only pre-existing ones).
  </verify>
  <done>
Gmail Pub/Sub endpoint exists at POST /webhooks/gmail. Inbound emails trigger the full pipeline: fetch_new_messages -> get_message -> pre_check -> process_influencer_reply -> handle_negotiation_result -> send_reply. Gmail watch renewal runs as a background task. All GmailClient calls use asyncio.to_thread. History ID updates are protected by asyncio.Lock.
  </done>
</task>

</tasks>

<verification>
- `grep "on_event" src/negotiation/app.py` returns nothing (deprecated pattern removed)
- `grep "lifespan" src/negotiation/app.py` shows the lifespan context manager
- `grep "SlackDispatcher" src/negotiation/app.py` shows initialization
- `grep "GmailClient" src/negotiation/app.py` shows initialization
- `grep "process_influencer_reply" src/negotiation/app.py` shows it is called
- `grep "webhooks/gmail" src/negotiation/app.py` shows the endpoint
- `grep "asyncio.to_thread" src/negotiation/app.py` shows wrapping of sync calls
- All 661+ tests pass
- ruff and mypy pass on modified files
</verification>

<success_criteria>
1. Deprecated on_event replaced with lifespan context manager
2. GmailClient, Anthropic client, and SlackDispatcher all initialized in initialize_services
3. POST /webhooks/gmail endpoint receives Pub/Sub notifications and triggers email processing
4. process_inbound_email wires the full pipeline: get_message -> pre_check -> process_influencer_reply -> handle_negotiation_result -> send_reply
5. Gmail watch registered on startup and renewed every 6 days
6. All sync Google API calls wrapped in asyncio.to_thread
7. History ID updates protected by asyncio.Lock
8. webhook.py converted to Router pattern
9. All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-runtime-orchestration-wiring/06-01-SUMMARY.md`
</output>
