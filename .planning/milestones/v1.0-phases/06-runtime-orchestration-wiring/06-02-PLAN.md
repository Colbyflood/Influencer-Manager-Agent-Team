---
phase: 06-runtime-orchestration-wiring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/negotiation/app.py
autonomous: true
requirements: []
gap_closure: true

must_haves:
  truths:
    - "When campaign ingestion returns found_influencers, negotiations are automatically started for each one"
    - "CampaignCPMTracker is instantiated per campaign with the campaign's CPM range and influencer count"
    - "Each found influencer gets a PayRange lookup, initial offer calculation, state machine, and initial email send"
    - "New negotiation state entries are stored in negotiation_states dict keyed by thread_id"
    - "Initial outreach emails are composed and sent via GmailClient"
    - "Campaign ingestion audit trail logs negotiation starts"
  artifacts:
    - path: "src/negotiation/app.py"
      provides: "start_negotiations_for_campaign function and extended campaign_processor"
      contains: "start_negotiations_for_campaign"
  key_links:
    - from: "campaign_processor in app.py"
      to: "start_negotiations_for_campaign"
      via: "asyncio.ensure_future after audited_ingest returns"
      pattern: "start_negotiations_for_campaign"
    - from: "start_negotiations_for_campaign"
      to: "negotiation.pricing.calculate_initial_offer"
      via: "function call to compute first offer"
      pattern: "calculate_initial_offer"
    - from: "start_negotiations_for_campaign"
      to: "negotiation.campaign.cpm_tracker.CampaignCPMTracker"
      via: "instantiated per campaign"
      pattern: "CampaignCPMTracker"
    - from: "start_negotiations_for_campaign"
      to: "gmail_client.send"
      via: "asyncio.to_thread for initial outreach email"
      pattern: "gmail_client.send"
---

<objective>
Wire campaign ingestion to automatically start negotiations for found influencers. After ingest_campaign returns, consume found_influencers to calculate initial offers, compose outreach emails, send them via GmailClient, and store negotiation state for each new thread. Instantiate CampaignCPMTracker per campaign.

Purpose: Closes MISSING-04 (campaign ingestion does not start negotiations) and wires CampaignCPMTracker (tech debt item). This completes the second broken E2E flow: "Campaign Ingestion -> Negotiation Start".

Output: Extended app.py with start_negotiations_for_campaign function and updated campaign_processor callback.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-runtime-orchestration-wiring/06-RESEARCH.md
@.planning/phases/06-runtime-orchestration-wiring/06-01-SUMMARY.md
@src/negotiation/app.py
@src/negotiation/campaign/ingestion.py
@src/negotiation/campaign/cpm_tracker.py
@src/negotiation/campaign/models.py
@src/negotiation/pricing/engine.py
@src/negotiation/email/client.py
@src/negotiation/email/models.py
@src/negotiation/sheets/client.py
@src/negotiation/sheets/models.py
@src/negotiation/state_machine/machine.py
@src/negotiation/llm/composer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add start_negotiations_for_campaign and build_negotiation_context helper</name>
  <files>src/negotiation/app.py</files>
  <action>
Add two functions to app.py:

**1. build_negotiation_context helper:**
```python
def build_negotiation_context(
    influencer_name: str,
    influencer_email: str,
    sheet_data: Any,  # InfluencerRow
    campaign: Any,  # Campaign model
    thread_id: str,
    cpm_tracker: Any | None = None,
) -> dict[str, Any]:
    """Assemble the negotiation_context dict that process_influencer_reply expects.

    Args:
        influencer_name: The influencer's name.
        influencer_email: The influencer's email address.
        sheet_data: InfluencerRow from Sheets lookup.
        campaign: The Campaign model from ingestion.
        thread_id: The Gmail thread ID for this conversation.
        cpm_tracker: Optional CampaignCPMTracker for flexibility guidance.

    Returns:
        A dict matching process_influencer_reply's expected negotiation_context keys.
    """
    from decimal import Decimal

    # Determine target CPM -- use tracker flexibility if available, else campaign floor
    next_cpm = campaign.cpm_range.min_cpm
    if cpm_tracker is not None:
        engagement_rate = getattr(sheet_data, "engagement_rate", None)
        flexibility = cpm_tracker.get_flexibility(
            influencer_engagement_rate=engagement_rate,
        )
        next_cpm = flexibility.target_cpm

    # Build deliverable types from campaign influencers or target_deliverables
    deliverable_types = [campaign.target_deliverables]

    return {
        "influencer_name": influencer_name,
        "influencer_email": influencer_email,
        "thread_id": thread_id,
        "platform": str(sheet_data.platform) if hasattr(sheet_data, "platform") else str(campaign.platform),
        "average_views": int(sheet_data.average_views),
        "deliverables_summary": campaign.target_deliverables,
        "deliverable_types": deliverable_types,
        "next_cpm": next_cpm,
        "client_name": campaign.client_name,
        "campaign_id": campaign.campaign_id,
        "history": "",
    }
```

**2. start_negotiations_for_campaign async function:**
```python
async def start_negotiations_for_campaign(
    found_influencers: list[dict[str, Any]],
    campaign: Any,
    services: dict[str, Any],
) -> None:
    """Start negotiations for each found influencer from campaign ingestion.

    For each influencer:
    1. Get PayRange from Sheet data
    2. Calculate initial offer using pricing engine
    3. Create NegotiationStateMachine
    4. Instantiate CampaignCPMTracker for per-influencer flexibility
    5. Compose initial outreach email using compose_counter_email with stage="initial_outreach"
    6. Send via GmailClient.send() as a new thread
    7. Store negotiation state in negotiation_states[thread_id]

    Args:
        found_influencers: List of dicts with "name" and "sheet_data" (InfluencerRow) keys.
        campaign: The Campaign model from ingestion.
        services: The services dict from initialize_services.
    """
    gmail_client = services.get("gmail_client")
    anthropic_client = services.get("anthropic_client")
    negotiation_states = services.get("negotiation_states", {})
    audit_logger = services.get("audit_logger")

    if gmail_client is None:
        logger.warning("GmailClient not available, cannot start negotiations")
        return

    if anthropic_client is None:
        logger.warning("Anthropic client not available, cannot compose outreach emails")
        return

    # Instantiate CampaignCPMTracker for this campaign
    from negotiation.campaign.cpm_tracker import CampaignCPMTracker
    from negotiation.pricing import calculate_initial_offer
    from negotiation.state_machine import NegotiationStateMachine
    from negotiation.llm.composer import compose_counter_email
    from negotiation.llm.knowledge_base import load_knowledge_base
    from negotiation.email.models import OutboundEmail

    cpm_tracker = CampaignCPMTracker(
        campaign_id=campaign.campaign_id,
        target_min_cpm=campaign.cpm_range.min_cpm,
        target_max_cpm=campaign.cpm_range.max_cpm,
        total_influencers=len(found_influencers),
    )

    for influencer_data in found_influencers:
        name = influencer_data["name"]
        sheet_data = influencer_data["sheet_data"]  # InfluencerRow

        try:
            # Calculate initial offer
            initial_rate = calculate_initial_offer(int(sheet_data.average_views))

            # Create state machine
            state_machine = NegotiationStateMachine()

            # Compose initial outreach email
            # Reuse compose_counter_email with negotiation_stage="initial_outreach"
            kb_content = load_knowledge_base(str(sheet_data.platform) if hasattr(sheet_data, "platform") else str(campaign.platform))

            composed = compose_counter_email(
                influencer_name=name,
                their_rate="not yet discussed",
                our_rate=str(initial_rate),
                deliverables_summary=campaign.target_deliverables,
                platform=str(sheet_data.platform) if hasattr(sheet_data, "platform") else str(campaign.platform),
                negotiation_stage="initial_outreach",
                knowledge_base_content=kb_content,
                negotiation_history="",
                client=anthropic_client,
            )

            # Send as a new email (not a reply -- new thread)
            influencer_email = str(sheet_data.email) if hasattr(sheet_data, "email") else ""
            if not influencer_email:
                logger.warning("No email for influencer, skipping", influencer=name)
                continue

            outbound = OutboundEmail(
                to=influencer_email,
                subject=f"Collaboration Opportunity - {campaign.client_name}",
                body=composed.email_body,
            )

            send_result = await asyncio.to_thread(gmail_client.send, outbound)
            thread_id = send_result.get("threadId", "")

            # Trigger state machine transition
            state_machine.trigger("send_offer")

            # Build negotiation context and store state
            context = build_negotiation_context(
                influencer_name=name,
                influencer_email=influencer_email,
                sheet_data=sheet_data,
                campaign=campaign,
                thread_id=thread_id,
                cpm_tracker=cpm_tracker,
            )

            negotiation_states[thread_id] = {
                "state_machine": state_machine,
                "context": context,
                "round_count": 0,
                "campaign": campaign,
                "cpm_tracker": cpm_tracker,
            }

            # Log to audit trail
            if audit_logger is not None:
                audit_logger.log_email_sent(
                    campaign_id=campaign.campaign_id,
                    influencer_name=name,
                    thread_id=thread_id,
                    email_body=composed.email_body,
                    negotiation_state="initial_offer",
                    rates_used=str(initial_rate),
                )

            logger.info(
                "Initial outreach sent",
                influencer=name,
                thread_id=thread_id,
                initial_rate=str(initial_rate),
                campaign=campaign.client_name,
            )

        except Exception:
            logger.exception("Failed to start negotiation for influencer", influencer=name)
```
  </action>
  <verify>
1. `python -c "from negotiation.app import start_negotiations_for_campaign, build_negotiation_context; print('OK')"` imports successfully.
2. `grep "CampaignCPMTracker" src/negotiation/app.py` shows it is instantiated.
3. `grep "calculate_initial_offer" src/negotiation/app.py` shows it is called.
4. `grep "NegotiationStateMachine" src/negotiation/app.py` shows it is created per influencer.
5. `python -m ruff check src/negotiation/app.py` -- no lint errors.
  </verify>
  <done>
start_negotiations_for_campaign function exists and wires: CampaignCPMTracker instantiation, calculate_initial_offer, NegotiationStateMachine creation, compose_counter_email for initial outreach, GmailClient.send, and negotiation state storage. build_negotiation_context helper assembles the context dict.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend campaign_processor to consume found_influencers and start negotiations</name>
  <files>src/negotiation/app.py</files>
  <action>
Modify the `campaign_processor` closure inside `initialize_services()` to call `start_negotiations_for_campaign` after `audited_ingest` returns.

The current `campaign_processor` calls `audited_ingest(task_id, clickup_token, sheets_client, slack_notifier)` and ignores the return value. Change it to:

```python
def campaign_processor(task_id: str) -> None:
    """Process a campaign task from webhook, running the async ingest and starting negotiations."""
    async def _process() -> None:
        result = await audited_ingest(
            task_id,
            clickup_token,
            sheets_client,
            slack_notifier,
        )
        # After ingestion, start negotiations for found influencers
        found_influencers = result.get("found_influencers", [])
        campaign = result.get("campaign")
        if found_influencers and campaign and services.get("gmail_client"):
            await start_negotiations_for_campaign(
                found_influencers=found_influencers,
                campaign=campaign,
                services=services,
            )
            logger.info(
                "Negotiations started for campaign",
                campaign=campaign.client_name,
                influencer_count=len(found_influencers),
            )
        elif not found_influencers:
            logger.info("No influencers found for campaign, no negotiations to start")

    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            task = asyncio.ensure_future(_process())
            background_tasks.add(task)
            task.add_done_callback(background_tasks.discard)
        else:
            loop.run_until_complete(_process())
    except Exception:
        logger.exception("Campaign processing failed", task_id=task_id)
```

Key changes from original:
1. `audited_ingest` result is now captured (was previously fire-and-forget).
2. After ingestion, `found_influencers` and `campaign` are extracted from result.
3. If influencers were found AND gmail_client is available, `start_negotiations_for_campaign` is called.
4. The inner async function `_process` encapsulates both ingestion and negotiation start.

Ensure `services` is in scope for the closure (it already is since `campaign_processor` is defined inside `initialize_services`).
  </action>
  <verify>
1. `grep "start_negotiations_for_campaign" src/negotiation/app.py` shows it is called from campaign_processor.
2. `grep "found_influencers" src/negotiation/app.py` shows the result is consumed.
3. `cd /Users/colbyflood/Influencer\ Manager\ Agent\ Team/Influencer-Manager-Agent-Team && python -m pytest tests/ -x -q` -- all tests pass.
4. `python -m ruff check src/negotiation/app.py` -- no lint errors.
5. `python -m mypy src/negotiation/app.py --strict` -- no new type errors.
  </verify>
  <done>
Campaign processor now consumes found_influencers from ingestion result and starts negotiations via start_negotiations_for_campaign. CampaignCPMTracker is instantiated per campaign. The full flow works: ClickUp webhook -> campaign ingestion -> Sheet lookup -> initial offer calculation -> email composition -> Gmail send -> negotiation state stored.
  </done>
</task>

</tasks>

<verification>
- `grep "start_negotiations_for_campaign" src/negotiation/app.py` shows both the function definition and its call from campaign_processor
- `grep "CampaignCPMTracker" src/negotiation/app.py` shows instantiation
- `grep "calculate_initial_offer" src/negotiation/app.py` shows pricing engine usage
- `grep "NegotiationStateMachine" src/negotiation/app.py` shows state machine creation
- `grep "negotiation_states\[" src/negotiation/app.py` shows state storage
- `grep "log_email_sent" src/negotiation/app.py` shows audit logging
- All 661+ tests pass
- ruff and mypy pass on modified files
</verification>

<success_criteria>
1. Campaign processor consumes found_influencers and calls start_negotiations_for_campaign
2. CampaignCPMTracker instantiated per campaign with correct CPM range
3. Each influencer gets: PayRange from sheet_data, calculate_initial_offer, NegotiationStateMachine, compose_counter_email with "initial_outreach" stage
4. Initial outreach emails sent via GmailClient.send (wrapped in asyncio.to_thread)
5. Negotiation state stored in negotiation_states dict keyed by thread_id
6. Audit trail logs initial email sends
7. All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-runtime-orchestration-wiring/06-02-SUMMARY.md`
</output>
