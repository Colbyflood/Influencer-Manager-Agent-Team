---
phase: 06-runtime-orchestration-wiring
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - tests/test_app.py
  - tests/test_orchestration.py
autonomous: true
requirements: []
gap_closure: true

must_haves:
  truths:
    - "Tests verify GmailClient initialization in initialize_services"
    - "Tests verify SlackDispatcher initialization in initialize_services"
    - "Tests verify Anthropic client initialization in initialize_services"
    - "Tests verify lifespan replaces on_event (no on_event in app)"
    - "Tests verify /webhooks/gmail endpoint exists and handles Pub/Sub notifications"
    - "Tests verify process_inbound_email wires the full pipeline"
    - "Tests verify start_negotiations_for_campaign creates state entries"
    - "Tests verify campaign_processor consumes found_influencers"
    - "All 4 MISSING gaps from milestone audit are verifiably closed"
  artifacts:
    - path: "tests/test_app.py"
      provides: "Updated tests for new initialize_services entries"
      contains: "gmail_client"
    - path: "tests/test_orchestration.py"
      provides: "Integration tests for orchestration wiring"
      contains: "test_process_inbound_email"
  key_links:
    - from: "tests/test_orchestration.py"
      to: "src/negotiation/app.py"
      via: "imports and tests orchestration functions"
      pattern: "from negotiation.app import"
---

<objective>
Update existing tests and add integration tests verifying the orchestration wiring works end-to-end with mocked external services. Verify all 4 MISSING gaps and 2 broken flows from the milestone audit are closed.

Purpose: Ensures the wiring from plans 06-01 and 06-02 actually connects correctly. Tests use mocks for GmailClient, SlackDispatcher, and Anthropic to verify the pipeline flow without real credentials.

Output: Updated test_app.py and new test_orchestration.py with integration tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-runtime-orchestration-wiring/06-RESEARCH.md
@.planning/phases/06-runtime-orchestration-wiring/06-01-SUMMARY.md
@.planning/phases/06-runtime-orchestration-wiring/06-02-SUMMARY.md
@src/negotiation/app.py
@tests/test_app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update test_app.py for new service initialization and Router pattern</name>
  <files>tests/test_app.py</files>
  <action>
Update existing tests in test_app.py to account for changes from 06-01:

1. **Update imports** -- if test imports `webhook_app` or references the old FastAPI app from webhook.py, update to use the router pattern. The `create_app` now creates its own FastAPI instance.

2. **Add test for GmailClient initialization:**
```python
def test_gmail_client_initialized_with_token(self, monkeypatch, tmp_path):
    """GmailClient is created when GMAIL_TOKEN_PATH is set."""
    monkeypatch.setenv("GMAIL_TOKEN_PATH", str(tmp_path / "token.json"))
    monkeypatch.setenv("AGENT_EMAIL", "agent@example.com")
    # Mock the credential + client creation
    with patch("negotiation.app.get_gmail_service" , ...) or local import mock:
        ...
    # Verify services["gmail_client"] is not None
```
Use the existing test patterns from test_app.py (monkeypatch + MagicMock).

3. **Add test for SlackDispatcher initialization:**
```python
def test_slack_dispatcher_initialized_when_notifier_available(self, monkeypatch, tmp_path):
    """SlackDispatcher is created when SlackNotifier and ThreadStateManager exist."""
    # Set up env vars for Slack
    monkeypatch.setenv("SLACK_BOT_TOKEN", "xoxb-test")
    monkeypatch.setenv("AGENT_EMAIL", "agent@example.com")
    # Mock dependencies, verify services["slack_dispatcher"] is not None
```

4. **Add test for Anthropic client initialization:**
```python
def test_anthropic_client_initialized_with_api_key(self, monkeypatch):
    """Anthropic client is created when ANTHROPIC_API_KEY is set."""
    monkeypatch.setenv("ANTHROPIC_API_KEY", "test-key")
    # Mock get_anthropic_client, verify services["anthropic_client"] is not None
```

5. **Add test for graceful degradation (each service):**
```python
def test_gmail_client_none_without_token(self, monkeypatch):
    """GmailClient is None when GMAIL_TOKEN_PATH is not set."""
    monkeypatch.delenv("GMAIL_TOKEN_PATH", raising=False)
    services = initialize_services()
    assert services["gmail_client"] is None

def test_slack_dispatcher_none_without_notifier(self, monkeypatch):
    """SlackDispatcher is None when SlackNotifier is unavailable."""
    monkeypatch.delenv("SLACK_BOT_TOKEN", raising=False)
    services = initialize_services()
    assert services["slack_dispatcher"] is None

def test_anthropic_client_none_without_key(self, monkeypatch):
    """Anthropic client is None when ANTHROPIC_API_KEY is not set."""
    monkeypatch.delenv("ANTHROPIC_API_KEY", raising=False)
    services = initialize_services()
    assert services["anthropic_client"] is None
```

6. **Verify no on_event usage:**
```python
def test_no_deprecated_on_event(self):
    """Verify deprecated on_event pattern is not used."""
    import inspect
    source = inspect.getsource(create_app)
    assert "on_event" not in source
```

7. **Verify lifespan is set:**
```python
def test_create_app_uses_lifespan(self):
    """FastAPI app uses lifespan context manager."""
    services = {"audit_conn": None, "gmail_client": None, ...}
    app = create_app(services)
    assert app.router.lifespan_context is not None
```

8. **Update any tests that reference `webhook_app` directly** -- they should now use `create_app(services)` which includes the webhook router.

Follow existing test patterns: use `monkeypatch` for env vars, `MagicMock`/`patch` for external dependencies, keep tests focused on one assertion.
  </action>
  <verify>
1. `cd /Users/colbyflood/Influencer\ Manager\ Agent\ Team/Influencer-Manager-Agent-Team && python -m pytest tests/test_app.py -x -v` -- all tests pass including new ones.
2. `python -m pytest tests/test_app.py -v --tb=short 2>&1 | grep -c "PASSED"` -- count confirms new tests exist.
  </verify>
  <done>
test_app.py includes tests for: GmailClient initialization/degradation, SlackDispatcher initialization/degradation, Anthropic client initialization/degradation, lifespan usage, no deprecated on_event, and Router pattern. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add orchestration integration tests for inbound email and campaign-to-negotiation flows</name>
  <files>tests/test_orchestration.py</files>
  <action>
Create a new test file `tests/test_orchestration.py` that tests the orchestration wiring with mocked external services.

**Test structure:**
```python
"""Integration tests for Phase 6 runtime orchestration wiring.

Tests verify the two E2E flows that were broken before Phase 6:
1. Inbound Email -> Negotiation Loop (MISSING-01, MISSING-02)
2. Campaign Ingestion -> Negotiation Start (MISSING-04)

Plus SlackDispatcher wiring (MISSING-03) and audit trail activation.

All external services (Gmail, Slack, Anthropic) are mocked.
"""
from __future__ import annotations

import asyncio
from decimal import Decimal
from unittest.mock import AsyncMock, MagicMock, patch
from typing import Any

import pytest

from negotiation.app import (
    build_negotiation_context,
    process_inbound_email,
    start_negotiations_for_campaign,
)
```

**Tests to include:**

1. **test_build_negotiation_context_assembles_correct_keys:**
   - Create mock InfluencerRow-like object with name, email, platform, average_views
   - Create mock Campaign-like object with cpm_range, client_name, campaign_id, target_deliverables, platform
   - Call build_negotiation_context and assert all required keys exist:
     `influencer_name`, `influencer_email`, `thread_id`, `platform`, `average_views`, `deliverables_summary`, `deliverable_types`, `next_cpm`, `client_name`, `campaign_id`, `history`

2. **test_build_negotiation_context_uses_cpm_tracker_flexibility:**
   - Create mock CampaignCPMTracker with get_flexibility returning CPMFlexibility(target_cpm=Decimal("25"), ...)
   - Verify context["next_cpm"] equals Decimal("25"), not the campaign floor

3. **test_process_inbound_email_full_pipeline:**
   - Create a services dict with mocked: gmail_client, slack_dispatcher, anthropic_client, negotiation_states (pre-populated with a thread), audited_process_reply
   - Mock gmail_client.get_message to return a mock InboundEmail
   - Mock audited_process_reply to return {"action": "send", "email_body": "counter offer"}
   - Mock dispatcher.pre_check to return None (proceed)
   - Mock dispatcher.handle_negotiation_result to pass through
   - Call `await process_inbound_email(msg_id, services)`
   - Assert: get_message called, pre_check called, process_reply called, send_reply called, round_count incremented

4. **test_process_inbound_email_skips_unknown_thread:**
   - Create services with empty negotiation_states
   - Mock gmail_client.get_message to return InboundEmail with unknown thread_id
   - Call process_inbound_email
   - Assert: get_message called, but process_reply NOT called, send_reply NOT called

5. **test_process_inbound_email_stops_on_precheck_gate:**
   - Pre-populate negotiation_states with a thread
   - Mock dispatcher.pre_check to return {"action": "skip", "reason": "human-managed"}
   - Call process_inbound_email
   - Assert: pre_check called, process_reply NOT called

6. **test_process_inbound_email_handles_escalation:**
   - Mock process_reply to return {"action": "escalate", "reason": "high CPM"}
   - Call process_inbound_email
   - Assert: send_reply NOT called, handle_negotiation_result IS called

7. **test_start_negotiations_creates_state_entries:**
   - Create mock services with gmail_client, anthropic_client, negotiation_states={}, audit_logger
   - Mock gmail_client.send to return {"threadId": "thread_123"}
   - Mock compose_counter_email to return mock with email_body attribute
   - Create found_influencers list with one entry
   - Create mock campaign
   - Call `await start_negotiations_for_campaign(found_influencers, campaign, services)`
   - Assert: negotiation_states["thread_123"] exists with state_machine, context, round_count=0
   - Assert: gmail_client.send called once
   - Assert: audit_logger.log_email_sent called

8. **test_start_negotiations_skips_without_gmail:**
   - Set services["gmail_client"] = None
   - Call start_negotiations_for_campaign
   - Assert: negotiation_states is still empty

9. **test_start_negotiations_instantiates_cpm_tracker:**
   - Verify CampaignCPMTracker is created with campaign's CPM range
   - Patch CampaignCPMTracker and assert it was called with correct args

For all async tests, use `@pytest.mark.asyncio` decorator. For mocking GmailClient's synchronous methods inside asyncio.to_thread, the mock will work since to_thread just calls the function in a thread and MagicMock is thread-safe for basic call tracking.

When mocking `asyncio.to_thread`, you can patch it to just call the function directly:
```python
async def mock_to_thread(fn, *args, **kwargs):
    return fn(*args, **kwargs)
```
Or use `AsyncMock` where appropriate.
  </action>
  <verify>
1. `cd /Users/colbyflood/Influencer\ Manager\ Agent\ Team/Influencer-Manager-Agent-Team && python -m pytest tests/test_orchestration.py -x -v` -- all tests pass.
2. `python -m pytest tests/test_orchestration.py -v --tb=short 2>&1 | grep -c "PASSED"` -- at least 8 tests pass.
3. `python -m ruff check tests/test_orchestration.py` -- no lint errors.
4. `cd /Users/colbyflood/Influencer\ Manager\ Agent\ Team/Influencer-Manager-Agent-Team && python -m pytest tests/ -x -q` -- all 670+ tests pass (661 original + new).
  </verify>
  <done>
test_orchestration.py exists with integration tests covering: build_negotiation_context, process_inbound_email (full pipeline, unknown thread, pre-check gate, escalation), start_negotiations_for_campaign (state creation, Gmail skip, CPMTracker instantiation). All tests pass. All 4 MISSING gaps verified closed via test coverage.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_app.py tests/test_orchestration.py -v` -- all tests pass
- `python -m pytest tests/ -x -q` -- full test suite passes (670+ tests)
- `python -m ruff check tests/test_app.py tests/test_orchestration.py` -- no lint errors
- Tests cover all 4 MISSING gaps:
  - MISSING-01: test_process_inbound_email_full_pipeline (process_influencer_reply called)
  - MISSING-02: tests verify /webhooks/gmail route and process_inbound_email flow
  - MISSING-03: tests verify SlackDispatcher initialization and pre_check/handle_result calls
  - MISSING-04: test_start_negotiations_creates_state_entries
</verification>

<success_criteria>
1. test_app.py updated with tests for new service initialization (GmailClient, SlackDispatcher, Anthropic)
2. test_app.py verifies lifespan replaces on_event
3. test_orchestration.py tests process_inbound_email full pipeline with mocks
4. test_orchestration.py tests start_negotiations_for_campaign with mocks
5. test_orchestration.py tests pre-check gate, escalation, unknown thread handling
6. All 4 MISSING gaps from milestone audit have corresponding test coverage
7. Full test suite (670+ tests) passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-runtime-orchestration-wiring/06-03-SUMMARY.md`
</output>
