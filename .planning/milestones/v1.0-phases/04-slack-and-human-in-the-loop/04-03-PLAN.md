---
phase: 04-slack-and-human-in-the-loop
plan: 03
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - src/negotiation/slack/takeover.py
  - src/negotiation/slack/commands.py
  - src/negotiation/slack/app.py
  - src/negotiation/slack/__init__.py
  - tests/slack/test_takeover.py
  - tests/slack/test_commands.py
autonomous: true
requirements:
  - HUMAN-04

must_haves:
  truths:
    - "detect_human_reply identifies when a non-agent, non-influencer sender has replied in a Gmail thread"
    - "Thread state tracks which threads are human-managed vs agent-managed"
    - "/claim command marks a thread as human-managed and agent stops processing it"
    - "/resume command hands a thread back to the agent for autonomous processing"
    - "is_human_managed returns True for claimed threads and threads with detected human replies"
    - "Silent handoff: no Slack notification when human takes over, agent just stops"
  artifacts:
    - path: "src/negotiation/slack/takeover.py"
      provides: "detect_human_reply, ThreadStateManager with claim/resume/is_human_managed"
      min_lines: 60
    - path: "src/negotiation/slack/commands.py"
      provides: "/claim and /resume slash command handlers"
      min_lines: 40
    - path: "src/negotiation/slack/app.py"
      provides: "Bolt App initialization with Socket Mode, slash command registration"
      min_lines: 30
    - path: "tests/slack/test_takeover.py"
      provides: "Tests for human reply detection and thread state management"
      min_lines: 80
    - path: "tests/slack/test_commands.py"
      provides: "Tests for slash command handlers"
      min_lines: 40
  key_links:
    - from: "src/negotiation/slack/takeover.py"
      to: "Gmail API threads.get"
      via: "service.users().threads().get() with format=metadata and From header inspection"
      pattern: "threads.*get"
    - from: "src/negotiation/slack/commands.py"
      to: "src/negotiation/slack/takeover.py"
      via: "Command handlers call ThreadStateManager.claim_thread and resume_thread"
      pattern: "claim_thread|resume_thread"
    - from: "src/negotiation/slack/app.py"
      to: "src/negotiation/slack/commands.py"
      via: "Bolt app registers command handlers"
      pattern: "app\\.command"
---

<objective>
Implement human takeover detection via Gmail thread inspection, thread state management for tracking human-managed threads, and Slack slash commands (/claim, /resume) for explicit takeover and handback.

Purpose: HUMAN-04 requires the agent to stop autonomous handling when a human replies in a thread. Both email detection and Slack command methods must be supported per locked decision. Silent handoff with no notification.
Output: Working human detection, thread state tracking, and slash command handlers ready for integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/04-slack-and-human-in-the-loop/04-RESEARCH.md
@.planning/phases/04-slack-and-human-in-the-loop/04-CONTEXT.md
@.planning/phases/04-slack-and-human-in-the-loop/04-01-SUMMARY.md
@src/negotiation/email/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Human reply detection and thread state management</name>
  <files>
    src/negotiation/slack/takeover.py
    tests/slack/test_takeover.py
  </files>
  <action>
    1. Create `src/negotiation/slack/takeover.py` with:

       **`detect_human_reply(service, thread_id, agent_email, influencer_email) -> bool`:**
       - Fetch thread via `service.users().threads().get(userId="me", id=thread_id, format="metadata", metadataHeaders=["From"])`.
       - Extract `From` header from each message in thread.
       - Use `email.utils.parseaddr()` (stdlib, per RESEARCH.md "don't hand-roll") to extract email address from `From` header (handles both `"Name <email>"` and plain `"email"` formats).
       - Build set of known senders: `{agent_email.lower(), influencer_email.lower()}`.
       - If any message's `From` email is not in known senders, return `True`.
       - Otherwise return `False`.
       - Use `Any` type for Gmail service parameter (same pattern as Phase 2 GmailClient).

       **`ThreadStateManager` class (in-memory dict for v1):**
       - Internal `_state: dict[str, dict[str, str | None]]` mapping `thread_id -> {"managed_by": "human"|"agent", "claimed_by": user_id|None}`.
       - `claim_thread(thread_id, user_id) -> None`: Set thread to human-managed with user_id.
       - `resume_thread(thread_id) -> None`: Set thread to agent-managed, clear claimed_by.
       - `is_human_managed(thread_id) -> bool`: Return True if thread is human-managed.
       - `get_claimed_by(thread_id) -> str | None`: Return user_id who claimed the thread.

    2. Create `tests/slack/test_takeover.py`:
       - **detect_human_reply tests (mock Gmail API):**
         - Test returns False when only agent and influencer emails present
         - Test returns True when a third-party email is present
         - Test handles "Name <email>" format via parseaddr
         - Test handles plain email format
         - Test is case-insensitive
         - Test empty thread returns False
       - **ThreadStateManager tests:**
         - Test new thread is agent-managed by default (is_human_managed returns False)
         - Test claim_thread makes is_human_managed return True
         - Test resume_thread makes is_human_managed return False again
         - Test get_claimed_by returns correct user_id after claim
         - Test get_claimed_by returns None for unclaimed thread

    3. Run `uv run ruff check src/negotiation/slack/takeover.py tests/slack/test_takeover.py --fix`.
    4. Run `uv run mypy src/negotiation/slack/takeover.py`.
    5. Run `uv run pytest tests/slack/test_takeover.py -v`.
  </action>
  <verify>
    `uv run pytest tests/slack/test_takeover.py -v` -- all tests pass.
    `uv run ruff check src/negotiation/slack/takeover.py` -- no lint errors.
    `uv run mypy src/negotiation/slack/takeover.py` -- no type errors.
  </verify>
  <done>
    detect_human_reply correctly identifies non-agent, non-influencer senders in a Gmail thread using parseaddr for robust email extraction. ThreadStateManager tracks human-managed threads with claim/resume/is_human_managed operations. All tests pass with mocked Gmail API.
  </done>
</task>

<task type="auto">
  <name>Task 2: Slack slash commands and Bolt app setup</name>
  <files>
    src/negotiation/slack/commands.py
    src/negotiation/slack/app.py
    src/negotiation/slack/__init__.py
    tests/slack/test_commands.py
  </files>
  <action>
    1. Create `src/negotiation/slack/commands.py` with slash command handlers:

       **`register_commands(app, thread_state_manager) -> None`:**
       Register `/claim` and `/resume` commands on the provided Bolt app.

       **`/claim` handler:**
       - `ack()` immediately (per RESEARCH.md Pitfall 2 -- must ack within 3 seconds).
       - Parse `command["text"].strip()` as the influencer identifier (name or email).
       - If empty text, `respond("Usage: /claim <influencer_name_or_email>")` and return.
       - Call `thread_state_manager.claim_thread(identifier, command["user_id"])`.
       - `respond(f"Thread claimed for {identifier}. Agent will stop processing this negotiation.")`.
       - Per locked decision: silent handoff, no Slack notification posted to channel.

       **`/resume` handler:**
       - `ack()` immediately.
       - Parse `command["text"].strip()` as the influencer identifier.
       - If empty text, `respond("Usage: /resume <influencer_name_or_email>")` and return.
       - Call `thread_state_manager.resume_thread(identifier)`.
       - `respond(f"Thread resumed for {identifier}. Agent will handle this negotiation again.")`.

       Note: For v1, the identifier is used directly as the thread key. Phase 5 (campaign ingestion) can add proper thread-to-influencer lookup.

    2. Create `src/negotiation/slack/app.py` with Bolt App initialization:

       **`create_slack_app(bot_token=None) -> App`:**
       - Create `App(token=bot_token or os.environ["SLACK_BOT_TOKEN"])`.
       - Return the app instance.

       **`start_slack_app(app, app_token=None) -> None`:**
       - Create `SocketModeHandler(app, app_token or os.environ["SLACK_APP_TOKEN"])`.
       - Call `handler.start()`.

       Keep this module minimal -- just app creation and startup. Command registration happens via `register_commands()` from commands.py so the app and commands are independently testable.

    3. Update `src/negotiation/slack/__init__.py` to export: `ThreadStateManager`, `detect_human_reply`, `register_commands`, `create_slack_app`, `start_slack_app` (add to existing exports from 04-01).

    4. Create `tests/slack/test_commands.py`:
       - Test `/claim` with valid identifier responds with success message
       - Test `/claim` with empty text responds with usage message
       - Test `/claim` calls thread_state_manager.claim_thread with correct args
       - Test `/resume` with valid identifier responds with success message
       - Test `/resume` with empty text responds with usage message
       - Test `/resume` calls thread_state_manager.resume_thread
       Use mock `ack` and `respond` callables, and a real ThreadStateManager instance.

    5. Run `uv run ruff check src/negotiation/slack/ tests/slack/ --fix`.
    6. Run `uv run mypy src/negotiation/slack/`.
    7. Run `uv run pytest tests/slack/ -v` -- all tests pass.
    8. Run `uv run pytest` -- full suite passes (no regressions).
  </action>
  <verify>
    `uv run pytest tests/slack/test_commands.py -v` -- all command tests pass.
    `uv run pytest tests/slack/ -v` -- all slack tests pass.
    `uv run pytest` -- full suite passes.
    `uv run ruff check src/negotiation/slack/` -- no lint errors.
    `uv run mypy src/negotiation/slack/` -- no type errors.
  </verify>
  <done>
    /claim and /resume slash command handlers work with immediate ack() and respond(). ThreadStateManager is wired to commands for claim/resume operations. Bolt app creation and Socket Mode startup are separated for testability. Silent handoff per locked decision -- no Slack channel notification on takeover. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/slack/ -v` -- all slack tests pass (blocks, client, takeover, commands)
2. `uv run pytest` -- full suite passes (no regressions)
3. `uv run ruff check src/negotiation/slack/ tests/slack/` -- no lint errors
4. `uv run mypy src/negotiation/slack/` -- no type errors
5. `uv run python -c "from negotiation.slack import detect_human_reply, ThreadStateManager, register_commands, create_slack_app; print('Takeover imports OK')"` -- exports work
</verification>

<success_criteria>
- detect_human_reply correctly identifies human replies via Gmail thread metadata
- ThreadStateManager tracks human-managed vs agent-managed threads
- /claim marks a thread as human-managed with the claiming user's ID
- /resume hands a thread back to the agent
- Silent handoff: no Slack notification when human takes over
- All Slack module tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-slack-and-human-in-the-loop/04-03-SUMMARY.md`
</output>
