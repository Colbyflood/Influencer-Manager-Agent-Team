---
phase: 04-slack-and-human-in-the-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/negotiation/llm/models.py
  - src/negotiation/llm/__init__.py
  - src/negotiation/slack/__init__.py
  - src/negotiation/slack/models.py
  - src/negotiation/slack/client.py
  - src/negotiation/slack/blocks.py
  - config/escalation_triggers.yaml
  - tests/slack/__init__.py
  - tests/slack/test_blocks.py
  - tests/slack/test_client.py
autonomous: true
requirements:
  - HUMAN-01
  - HUMAN-03

user_setup:
  - service: slack
    why: "Slack Bot token for posting messages to channels"
    env_vars:
      - name: SLACK_BOT_TOKEN
        source: "Slack App Settings -> OAuth & Permissions -> Bot User OAuth Token (xoxb-...)"
      - name: SLACK_APP_TOKEN
        source: "Slack App Settings -> Basic Information -> App-Level Tokens -> Generate (connections:write scope, xapp-...)"
      - name: SLACK_ESCALATION_CHANNEL
        source: "Channel ID for escalation notifications (right-click channel -> View channel details -> copy ID)"
      - name: SLACK_AGREEMENT_CHANNEL
        source: "Channel ID for agreement notifications (right-click channel -> View channel details -> copy ID)"
    dashboard_config:
      - task: "Create Slack App"
        location: "https://api.slack.com/apps -> Create New App -> From scratch"
      - task: "Enable Socket Mode"
        location: "Slack App Settings -> Socket Mode -> Enable"
      - task: "Add Bot Token Scopes: chat:write, commands"
        location: "Slack App Settings -> OAuth & Permissions -> Scopes"
      - task: "Create slash commands: /claim and /resume"
        location: "Slack App Settings -> Slash Commands -> Create New Command"
      - task: "Install app to workspace"
        location: "Slack App Settings -> Install App -> Install to Workspace"

must_haves:
  truths:
    - "SlackNotifier can post Block Kit messages to separate escalation and agreement channels"
    - "Escalation blocks include influencer name, email, client name, reason, evidence, rates, suggested actions, and details link"
    - "Agreement blocks include influencer name, email, client name, agreed rate, platform, deliverables, CPM achieved, next steps, and @ mentions"
    - "EscalationPayload has Phase 4 fields (influencer_email, client_name, evidence_quote, suggested_actions, trigger_type)"
    - "AgreementPayload model exists with all required fields for agreement Slack alerts"
    - "Default YAML trigger config exists with all 5 triggers enabled"
  artifacts:
    - path: "src/negotiation/slack/client.py"
      provides: "SlackNotifier class wrapping WebClient for escalation and agreement channel posting"
      min_lines: 40
    - path: "src/negotiation/slack/blocks.py"
      provides: "build_escalation_blocks and build_agreement_blocks pure functions returning Block Kit dicts"
      min_lines: 80
    - path: "src/negotiation/slack/models.py"
      provides: "SlackConfig Pydantic model with channel IDs and default mention users"
      min_lines: 15
    - path: "src/negotiation/llm/models.py"
      provides: "Extended EscalationPayload with Phase 4 fields and new AgreementPayload model"
      contains: "class AgreementPayload"
    - path: "config/escalation_triggers.yaml"
      provides: "Team-editable YAML config for all 5 escalation trigger rules"
      min_lines: 20
  key_links:
    - from: "src/negotiation/slack/client.py"
      to: "slack_sdk.WebClient"
      via: "chat_postMessage with blocks parameter"
      pattern: "chat_postMessage"
    - from: "src/negotiation/slack/blocks.py"
      to: "src/negotiation/slack/client.py"
      via: "client receives block dicts built by blocks module"
      pattern: "list\\[dict\\]"
    - from: "src/negotiation/llm/models.py"
      to: "src/negotiation/slack/blocks.py"
      via: "EscalationPayload and AgreementPayload provide data for block builders"
      pattern: "AgreementPayload|EscalationPayload"
---

<objective>
Install Slack dependencies, create Pydantic models (extend EscalationPayload, new AgreementPayload), set up SlackNotifier client, Block Kit message builders, and default YAML trigger config file.

Purpose: Establish the foundation that all other Phase 4 plans depend on -- models, Slack client, message formatting, and config structure.
Output: Working Slack client with Block Kit builders, extended data models, and editable YAML config.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/04-slack-and-human-in-the-loop/04-RESEARCH.md
@.planning/phases/04-slack-and-human-in-the-loop/04-CONTEXT.md
@src/negotiation/llm/models.py
@src/negotiation/llm/__init__.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, extend models, create YAML config</name>
  <files>
    pyproject.toml
    src/negotiation/llm/models.py
    src/negotiation/llm/__init__.py
    src/negotiation/slack/__init__.py
    src/negotiation/slack/models.py
    config/escalation_triggers.yaml
  </files>
  <action>
    1. Install Phase 4 dependencies:
       ```
       uv add slack-sdk slack-bolt pyyaml
       ```

    2. Extend `EscalationPayload` in `src/negotiation/llm/models.py` with Phase 4 fields. Add these fields with defaults so existing Phase 3 code continues working:
       - `influencer_email: str = ""`
       - `client_name: str = ""`
       - `evidence_quote: str = ""`
       - `suggested_actions: list[str] = Field(default_factory=list)`
       - `trigger_type: str = ""`

    3. Add `AgreementPayload` model to `src/negotiation/llm/models.py`:
       ```python
       class AgreementPayload(BaseModel):
           """Data for agreement Slack notifications (HUMAN-03)."""
           influencer_name: str
           influencer_email: str
           client_name: str
           agreed_rate: Decimal
           platform: str
           deliverables: str
           cpm_achieved: Decimal
           thread_id: str
           next_steps: list[str] = Field(default_factory=list)
           mention_users: list[str] = Field(default_factory=list)
       ```

    4. Update `src/negotiation/llm/__init__.py` to export `AgreementPayload`. Add it to imports from `negotiation.llm.models` and to `__all__`. Run `ruff check --fix` to ensure proper sorting.

    5. Create `src/negotiation/slack/__init__.py` with docstring and placeholder `__all__` (will be populated as modules are created).

    6. Create `src/negotiation/slack/models.py` with `SlackConfig` Pydantic model:
       ```python
       class SlackConfig(BaseModel):
           """Configuration for Slack integration."""
           escalation_channel: str = Field(description="Channel ID for escalation messages")
           agreement_channel: str = Field(description="Channel ID for agreement alerts")
           default_mention_users: list[str] = Field(
               default_factory=list,
               description="Default Slack user IDs to @ mention on agreements"
           )
       ```

    7. Create `config/escalation_triggers.yaml` with all 5 triggers enabled by default. Include comments explaining each trigger per the RESEARCH.md example. Use `cpm_threshold: 30.0` as default.

    8. Run `uv run ruff check src/negotiation/llm/ src/negotiation/slack/ --fix` and `uv run mypy src/negotiation/llm/ src/negotiation/slack/` to verify.
  </action>
  <verify>
    `uv run python -c "from negotiation.llm.models import EscalationPayload, AgreementPayload; print(EscalationPayload.model_fields.keys()); print(AgreementPayload.model_fields.keys())"` prints both model field lists including Phase 4 additions.
    `uv run python -c "from negotiation.slack.models import SlackConfig; print(SlackConfig.model_fields.keys())"` prints config fields.
    `uv run ruff check src/negotiation/` passes.
    `uv run mypy src/negotiation/` passes.
    `cat config/escalation_triggers.yaml` shows all 5 triggers.
  </verify>
  <done>
    EscalationPayload has 5 new Phase 4 fields with backward-compatible defaults. AgreementPayload exists with all required agreement fields. SlackConfig model exists. YAML config file has all 5 triggers enabled with comments. All existing tests still pass (no regressions from model extension).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SlackNotifier client and Block Kit builders with tests</name>
  <files>
    src/negotiation/slack/client.py
    src/negotiation/slack/blocks.py
    src/negotiation/slack/__init__.py
    tests/slack/__init__.py
    tests/slack/test_blocks.py
    tests/slack/test_client.py
  </files>
  <action>
    1. Create `src/negotiation/slack/blocks.py` with two pure functions:

       `build_escalation_blocks(influencer_name, influencer_email, client_name, escalation_reason, evidence_quote, proposed_rate, our_rate, suggested_actions, details_link) -> list[dict]`:
       - Header block: "Escalation: {influencer_name}"
       - Section with fields: influencer name, email, client name, reason (4 fields per locked decision)
       - Conditional section with rate comparison fields (Their Rate / Our Rate) -- only if rates provided
       - Evidence quote section using mrkdwn blockquote (`>`) -- only if evidence provided
       - Suggested actions section as bullet list -- only if actions provided
       - Context block with details link using mrkdwn `<url|text>` format (Gmail thread permalink: `https://mail.google.com/mail/u/0/#inbox/{thread_id}`)
       Per locked decision: summary format with link, not everything inline. Specific reason with evidence.

       `build_agreement_blocks(influencer_name, influencer_email, client_name, agreed_rate, platform, deliverables, cpm_achieved, next_steps, mention_users) -> list[dict]`:
       - Header block: "Deal Agreed: {influencer_name}"
       - Section with fields: influencer name, email, client name, platform (4 fields)
       - Section with fields: agreed rate (formatted $X,XXX.XX), CPM achieved (formatted $XX.XX), deliverables (3 fields)
       - Next steps section as bullet list -- only if steps provided
       - Mention section with `<@USER_ID>` syntax -- only if mention_users provided
       Per locked decision: deal summary + next steps, configurable per-campaign tagging.

    2. Create `src/negotiation/slack/client.py` with `SlackNotifier` class:
       - `__init__(escalation_channel, agreement_channel, bot_token=None)`: Create WebClient from `bot_token` or `SLACK_BOT_TOKEN` env var. Store channel IDs.
       - `post_escalation(blocks, fallback_text) -> str`: Post to escalation channel via `chat_postMessage`, return message `ts`.
       - `post_agreement(blocks, fallback_text) -> str`: Post to agreement channel via `chat_postMessage`, return message `ts`.
       Use `from slack_sdk import WebClient` and `from slack_sdk.errors import SlackApiError`.

    3. Update `src/negotiation/slack/__init__.py` to export `SlackNotifier`, `SlackConfig`, `build_escalation_blocks`, `build_agreement_blocks`.

    4. Create `tests/slack/__init__.py` (empty).

    5. Create `tests/slack/test_blocks.py` with pure function tests (no mocks needed):
       - Test escalation blocks contain all required fields (name, email, client, reason)
       - Test escalation blocks include rate comparison when rates provided
       - Test escalation blocks omit rate section when rates are None
       - Test escalation blocks include evidence quote
       - Test escalation blocks include suggested actions
       - Test escalation blocks include details link
       - Test agreement blocks contain all required fields (name, email, client, rate, platform, deliverables, CPM)
       - Test agreement blocks include next steps
       - Test agreement blocks include @ mentions with `<@USER_ID>` syntax
       - Test agreement blocks omit mentions when list empty

    6. Create `tests/slack/test_client.py` with mocked WebClient tests:
       - Test `post_escalation` calls `chat_postMessage` with correct channel and blocks
       - Test `post_agreement` calls `chat_postMessage` with correct channel and blocks
       - Test both methods return message timestamp
       Inject mock via `notifier._client = mock_client` pattern.

    7. Run `uv run ruff check src/negotiation/slack/ tests/slack/ --fix` and `uv run mypy src/negotiation/slack/`.
    8. Run `uv run pytest tests/slack/ -v` to verify all tests pass.
    9. Run `uv run pytest` to verify no regressions across the full test suite.
  </action>
  <verify>
    `uv run pytest tests/slack/test_blocks.py -v` -- all block builder tests pass.
    `uv run pytest tests/slack/test_client.py -v` -- all client tests pass.
    `uv run pytest` -- full suite passes (no regressions).
    `uv run ruff check src/negotiation/slack/` passes.
    `uv run mypy src/negotiation/slack/` passes.
  </verify>
  <done>
    SlackNotifier posts Block Kit messages to separate escalation and agreement channels. Block builders produce correctly structured Block Kit JSON with all required fields per locked decisions. Pure function tests verify block structure without Slack API calls. Client tests verify correct channel routing with mocked WebClient.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest` -- full test suite passes including new slack tests
2. `uv run ruff check src/negotiation/ tests/` -- no lint errors
3. `uv run mypy src/negotiation/` -- no type errors
4. `uv run python -c "from negotiation.slack import SlackNotifier, build_escalation_blocks, build_agreement_blocks; print('Slack package imports OK')"` -- package exports work
5. `uv run python -c "from negotiation.llm import AgreementPayload, EscalationPayload; p = EscalationPayload(reason='test', email_draft='', influencer_name='x', thread_id='t'); print(p.influencer_email, p.client_name)"` -- backward compat confirmed
6. `cat config/escalation_triggers.yaml` -- all 5 triggers present and enabled
</verification>

<success_criteria>
- SlackNotifier can post to two separate channels (escalation and agreement)
- Block Kit builders produce valid Block Kit JSON for both escalation and agreement messages
- All required fields from locked decisions appear in the message blocks
- EscalationPayload extended with Phase 4 fields without breaking Phase 3
- AgreementPayload model is importable and has all required fields
- YAML config file exists with all 5 triggers enabled by default
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-slack-and-human-in-the-loop/04-01-SUMMARY.md`
</output>
