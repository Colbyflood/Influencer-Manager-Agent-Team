---
phase: 02-email-and-data-integration
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/negotiation/email/client.py
  - src/negotiation/email/threading.py
  - src/negotiation/email/parser.py
  - src/negotiation/email/__init__.py
  - tests/email/test_client.py
  - tests/email/test_threading.py
  - tests/email/test_parser.py
autonomous: true
requirements:
  - EMAIL-01
  - EMAIL-02
  - EMAIL-03
  - EMAIL-04

must_haves:
  truths:
    - "Agent can compose and send an email via Gmail API with correct MIME encoding"
    - "Agent can send a reply within an existing thread using threadId, In-Reply-To, and References headers"
    - "Agent can set up a Gmail watch on Pub/Sub and process notifications to detect new messages"
    - "Agent can fetch a raw Gmail message, decode its MIME structure, and extract the text body"
    - "Agent can extract only the latest reply text from a multi-message email thread"
  artifacts:
    - path: "src/negotiation/email/client.py"
      provides: "Gmail API operations: send, send_reply, setup_watch, fetch_new_messages, get_message_raw"
      exports: ["GmailClient"]
    - path: "src/negotiation/email/threading.py"
      provides: "Thread context extraction and reply header management"
      exports: ["get_thread_context", "build_reply_headers"]
    - path: "src/negotiation/email/parser.py"
      provides: "MIME parsing and reply text extraction"
      exports: ["parse_mime_message", "extract_latest_reply"]
  key_links:
    - from: "src/negotiation/email/client.py"
      to: "src/negotiation/auth/credentials.py"
      via: "Uses Gmail service from get_gmail_service"
      pattern: "get_gmail_service|service\\.users\\(\\)"
    - from: "src/negotiation/email/client.py"
      to: "src/negotiation/email/models.py"
      via: "Returns InboundEmail and accepts OutboundEmail"
      pattern: "InboundEmail|OutboundEmail"
    - from: "src/negotiation/email/client.py"
      to: "src/negotiation/email/threading.py"
      via: "Uses get_thread_context for reply operations"
      pattern: "get_thread_context|build_reply_headers"
    - from: "src/negotiation/email/client.py"
      to: "src/negotiation/email/parser.py"
      via: "Uses parse_mime_message and extract_latest_reply when fetching messages"
      pattern: "parse_mime_message|extract_latest_reply"
---

<objective>
Implement the Gmail API integration: sending emails, replying within threads, receiving notifications via Pub/Sub, and parsing email content from MIME messages.

Purpose: This is the email backbone the agent needs. Without send/receive/parse, the agent cannot negotiate via email. Threading ensures influencers see coherent conversations. Pub/Sub enables near-real-time detection of replies.

Output: GmailClient class wrapping all Gmail API operations, threading helpers for maintaining conversation continuity, and MIME parser for extracting reply content. All tested with mocked Gmail API responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-email-and-data-integration/02-RESEARCH.md
@.planning/phases/02-email-and-data-integration/02-01-SUMMARY.md
@src/negotiation/auth/credentials.py
@src/negotiation/email/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement email threading and MIME parser modules</name>
  <files>
    src/negotiation/email/threading.py
    src/negotiation/email/parser.py
    tests/email/test_threading.py
    tests/email/test_parser.py
  </files>
  <action>
    **src/negotiation/email/threading.py:**
    Create two functions:

    1. `get_thread_context(service, thread_id: str) -> EmailThreadContext` -- Calls `service.users().threads().get()` with `format="metadata"` and `metadataHeaders=["Message-ID", "Subject", "From"]`. Extracts headers from the last message in the thread. Returns an `EmailThreadContext` with thread_id, last_message_id (Message-ID header), subject, and influencer_email (From header). Follow research Pattern 3.

    2. `build_reply_headers(thread_ctx: EmailThreadContext) -> dict[str, str]` -- Given an EmailThreadContext, returns a dict with:
       - `"In-Reply-To"`: thread_ctx.last_message_id
       - `"References"`: thread_ctx.last_message_id
       - `"Subject"`: Prefixes "Re: " if not already present (case-insensitive check)
       - `"To"`: thread_ctx.influencer_email

    **src/negotiation/email/parser.py:**
    Create two functions:

    1. `parse_mime_message(raw_bytes: bytes) -> str` -- Takes raw email bytes (base64url-decoded), parses with `email.message_from_bytes()`. Extracts text/plain body from MIME structure. If multipart, walks parts to find text/plain. If no text/plain found, falls back to text/html and strips HTML tags using a simple regex (`re.sub(r'<[^>]+>', '', html_content)`). Returns the decoded text body. Handle encoding with `decode("utf-8", errors="replace")`. Follow research Pattern 4.

    2. `extract_latest_reply(full_body: str) -> str` -- Uses `mailparser_reply.EmailReplyParser(languages=["en"]).parse_reply(text=full_body)` to extract only the latest reply, stripping quoted content. Returns the extracted reply text. If extraction returns empty, return the original full_body as fallback.

    **Tests:**
    - `tests/email/test_threading.py`: Mock the Gmail API service to return a thread with messages containing specific headers. Test get_thread_context extracts correct thread_id, message_id, subject, from. Test build_reply_headers generates correct In-Reply-To, References, Subject (with and without existing "Re:" prefix). ~10-15 tests.
    - `tests/email/test_parser.py`: Test parse_mime_message with: plain text only, multipart with text/plain, multipart with only text/html (HTML stripping), empty body. Test extract_latest_reply with: simple reply, reply with quoted content ("On ... wrote:"), reply with forwarded content. Use fixture strings, not real emails. ~10-15 tests.

    Run: `uv run pytest tests/email/ -v`, `uv run ruff check src/negotiation/email/ tests/email/`, `uv run mypy src/negotiation/email/`.
  </action>
  <verify>
    `uv run pytest tests/email/test_threading.py tests/email/test_parser.py -v` -- all pass.
    `uv run ruff check src/negotiation/email/ tests/email/` -- clean.
    `uv run mypy src/negotiation/email/` -- clean.
  </verify>
  <done>
    get_thread_context extracts threading headers from Gmail API thread.
    build_reply_headers produces correct In-Reply-To, References, Subject for threaded replies.
    parse_mime_message handles plain text, multipart, and HTML-only MIME messages.
    extract_latest_reply strips quoted content and returns only the new reply text.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GmailClient class with send, receive, and watch operations</name>
  <files>
    src/negotiation/email/client.py
    src/negotiation/email/__init__.py
    tests/email/test_client.py
  </files>
  <action>
    **src/negotiation/email/client.py:**
    Create a `GmailClient` class that wraps the Gmail API service:

    ```python
    class GmailClient:
        def __init__(self, service, from_email: str):
            self._service = service
            self._from_email = from_email
    ```

    Methods:

    1. `send(outbound: OutboundEmail) -> dict` -- Composes an `email.message.EmailMessage`, sets To, From, Subject, body via `set_content()`. If outbound.thread_id is set, adds threadId to payload. If outbound.in_reply_to is set, adds In-Reply-To and References headers. Base64url-encodes the message and calls `service.users().messages().send(userId="me", body=payload).execute()`. Returns the API response dict. Follow research Pattern 1.

    2. `send_reply(thread_id: str, body: str) -> dict` -- Convenience method. Calls `get_thread_context(self._service, thread_id)` to get threading context. Calls `build_reply_headers(ctx)` to get headers. Constructs an OutboundEmail with the headers. Calls `self.send(outbound)`. Returns the API response.

    3. `setup_watch(topic_name: str) -> dict` -- Calls `service.users().watch(userId="me", body={"labelIds": ["INBOX"], "topicName": topic_name, "labelFilterBehavior": "INCLUDE"}).execute()`. Returns the response containing historyId and expiration. Follow research Pattern 2.

    4. `fetch_new_messages(history_id: str) -> tuple[list[str], str]` -- Calls `service.users().history().list(userId="me", startHistoryId=history_id, historyTypes=["messageAdded"]).execute()`. Iterates through history records to collect new message IDs. Returns (list of new message IDs, new history_id). Handles empty history (no new messages) gracefully.

    5. `get_message(message_id: str) -> InboundEmail` -- Calls `service.users().messages().get(userId="me", id=message_id, format="raw").execute()`. Decodes raw bytes with `base64.urlsafe_b64decode`. Uses `parse_mime_message()` to get full body text. Uses `extract_latest_reply()` to get just the reply. Also fetches metadata headers (Message-ID, From, Subject) from the message. Constructs and returns an InboundEmail model. Gets `internalDate` from message and converts to ISO 8601 for received_at.

    **src/negotiation/email/__init__.py:** Update to re-export GmailClient, get_thread_context, build_reply_headers, parse_mime_message, extract_latest_reply, plus the existing model exports. Sort __all__ alphabetically.

    **Tests (tests/email/test_client.py):**
    Use `unittest.mock.patch` and `unittest.mock.MagicMock` to mock the Gmail API service object.

    Test GmailClient.send:
    - Verify it base64url-encodes the message
    - Verify it sets threadId when provided
    - Verify it sets In-Reply-To/References headers when provided
    - Verify it calls `service.users().messages().send().execute()`

    Test GmailClient.send_reply:
    - Mock get_thread_context to return a known EmailThreadContext
    - Verify it calls send with correct threading headers
    - Verify Subject gets "Re: " prefix

    Test GmailClient.setup_watch:
    - Verify it calls `service.users().watch()` with correct body
    - Verify it returns historyId and expiration

    Test GmailClient.fetch_new_messages:
    - Mock history.list to return history records with messagesAdded
    - Verify it extracts correct message IDs
    - Test empty history case (no new messages)

    Test GmailClient.get_message:
    - Mock messages.get to return a raw message (create a real MIME message, base64url-encode it)
    - Verify it returns a correct InboundEmail with parsed body_text

    ~20-25 tests total.

    Run full test suite: `uv run pytest`, `uv run ruff check src/ tests/`, `uv run ruff format --check src/ tests/`, `uv run mypy src/`.
  </action>
  <verify>
    `uv run pytest` -- all tests pass (existing + plan 01 + plan 02 tests).
    `uv run ruff check src/ tests/` -- clean.
    `uv run ruff format --check src/ tests/` -- clean.
    `uv run mypy src/` -- clean.
  </verify>
  <done>
    GmailClient.send composes and sends MIME emails via Gmail API.
    GmailClient.send_reply extracts thread context and sends properly threaded replies.
    GmailClient.setup_watch registers Pub/Sub notifications for inbox changes.
    GmailClient.fetch_new_messages retrieves new message IDs from history since last check.
    GmailClient.get_message fetches, decodes, and parses a raw email into InboundEmail.
    All tests pass with mocked Gmail API, linters clean, mypy clean.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "from negotiation.email import GmailClient, get_thread_context, build_reply_headers, parse_mime_message, extract_latest_reply"` succeeds
2. `uv run pytest tests/email/ -v` -- all email tests pass
3. `uv run pytest` -- full suite passes (existing 227 + plan 01 tests + plan 02 tests)
4. `uv run ruff check src/ tests/` -- clean
5. `uv run mypy src/` -- clean
</verification>

<success_criteria>
- GmailClient wraps all 5 Gmail operations (send, send_reply, setup_watch, fetch_new_messages, get_message)
- Threading helpers ensure replies appear in the same conversation
- MIME parser extracts text from plain, multipart, and HTML-only emails
- Reply extractor strips quoted content to get only the new reply
- All operations tested with mocked Gmail API (~30-40 new tests)
- Zero coupling to real Gmail credentials (all tests use mocks)
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-and-data-integration/02-02-SUMMARY.md`
</output>
